<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sofia_redux.instruments.hawc.steps.stepfocus &#8212; sofia_redux v1.3.4.dev0</title>
    <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/bootstrap-sofia.css?v=3fe2c07e" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/plot_directive.css" />
    
    <script src="../../../../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script data-url_root="../../../../../" id="documentation_options" src="../../../../../_static/documentation_options.js?v=602f4d50"></script>
    <script src="../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script type="text/javascript" src="../../../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../../../_static/copybutton.js"></script>
    <link rel="icon" href="../../../../../_static/redux.ico"/>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../../../index.html"><span id="logotext1">SOFIA</span><span id="logotext2">Redux</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="SOFIA Homepage" href="https://www.sofia.usra.edu/"></a></li>
    <li><a title="General Index" href="../../../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../../../index.html">sofia_redux v1.3.4.dev0</a>
	 &#187;
      </li>
      <li><a href="../../../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sofia_redux.instruments.hawc.steps.stepfocus</h1><div class="highlight"><pre>
<span></span># Licensed under a 3-clause BSD style license - see LICENSE.rst
&quot;&quot;&quot;Focus analysis pipeline step.&quot;&quot;&quot;

from astropy import log
from astropy import wcs as astwcs
from matplotlib.backends.backend_agg \
    import FigureCanvasAgg as FigureCanvas
from matplotlib.figure import Figure
from matplotlib.patches import Ellipse
import numpy as np
from scipy import ndimage, optimize

from sofia_redux.instruments.hawc.stepmoparent import StepMOParent

__all__ = [&#39;StepFocus&#39;]


<div class="viewcode-block" id="StepFocus"><a class="viewcode-back" href="../../../../../api/sofia_redux.instruments.hawc.steps.stepfocus.StepFocus.html#sofia_redux.instruments.hawc.steps.stepfocus.StepFocus">[docs]</a>class StepFocus(StepMOParent):
    &quot;&quot;&quot;
    Calculate an optimal focus value from short calibration scans.

    This step fits and reports the best focus offset from a
    set of image with varying focus values.

    Input for this step is a set calibrated scan maps.  This step is
    typically run after
    `sofia_redux.instruments.hawc.steps.StepStdPhotCal`. The output from
    this step is identical to the input.  It is not typically saved.
    As a side effect, this step produces several PNG images of focus plots,
    written to the same directory and basename as the input file.
    &quot;&quot;&quot;
<div class="viewcode-block" id="StepFocus.setup"><a class="viewcode-back" href="../../../../../api/sofia_redux.instruments.hawc.steps.stepfocus.StepFocus.html#sofia_redux.instruments.hawc.steps.stepfocus.StepFocus.setup">[docs]</a>    def setup(self):
        &quot;&quot;&quot;
        Set parameters and metadata for the pipeline step.

        Output files have PRODTYPE = &#39;focus&#39;, and are named with
        the step abbreviation &#39;FCS&#39;.

        Parameters defined for this step are:

        widowisgood : bool
            Include widow pixels in the analysis if set.
        medianaverage : bool
            If set, replace missing pixels with a local median
            value.
        boxaverage : int
            Size of the box used in medianaverage.
        autocrop : bool
            If set, the image will be automatcally be cropped to
            center the target.
        cropimage : bool
            If set, the image will be cropped, using &#39;xyboxcent&#39;
            and &#39;boxsizecrop&#39; parameters; &#39;autocrop&#39; overrides
            this option if set.
        xyboxcent : list
            Central [x, y] pixel to crop around, if cropimage
            is set; &#39;autocrop&#39; overrides this option if set.
        boxsizecrop : int
            Box size to crop to, if cropimage is set; &#39;autocrop&#39;
            overrides this option if set.
        primaryimg : str
            Image extension name to use for the fit.  If blank,
            the first image extension is used.
        &quot;&quot;&quot;

        # Name of the pipeline reduction step
        self.name = &#39;focus&#39;
        self.description = &#39;Make Focus Plots&#39;

        # Shortcut for pipeline reduction step and identifier for
        # saved file names.
        self.procname = &#39;fcs&#39;

        # Clear Parameter list
        self.paramlist = []

        # Append parameters
        self.paramlist.append([&#39;widowisgood&#39;, True,
                               &#39;Include widow pixels in the analysis (T) &#39;
                               &#39;or only good, non-widow pixels (F)&#39;])
        self.paramlist.append([&#39;medianaverage&#39;, True,
                               &#39;Run a median average box through the array &#39;
                               &#39;to fill bad pixels (T) or not (F)&#39;])
        self.paramlist.append([&#39;boxaverage&#39;, 3,
                               &#39;Size of the median average box &#39;
                               &#39;(if medianaverage is True) in pixels&#39;])
        self.paramlist.append([&#39;autocrop&#39;, True,
                               &#39;Crop image automatically around the target &#39;
                               &#39;(w/ boxsize = 1/3 of image size)&#39;])
        self.paramlist.append([&#39;cropimage&#39;, False,
                               &#39;Crop portion (box) of the image &#39;
                               &#39;for analysis?&#39;])
        self.paramlist.append([&#39;xyboxcent&#39;, [32, 20],
                               &#39;If cropimage = True, central X/Y pixel &#39;
                               &#39;position of the box to be cropped&#39;])
        self.paramlist.append([&#39;boxsizecrop&#39;, 20,
                               &#39;If cropimage = True, size of the box &#39;
                               &#39;to be cropped (in pixels)&#39;])
        self.paramlist.append([&#39;primaryimg&#39;, &#39;&#39;,
                               &#39;Specifies which image will be used for &#39;
                               &#39;the Gaussian fit. If left blank, the &#39;
                               &#39;first image will be used.&#39;])</div>

<div class="viewcode-block" id="StepFocus.gaussian"><a class="viewcode-back" href="../../../../../api/sofia_redux.instruments.hawc.steps.stepfocus.StepFocus.html#sofia_redux.instruments.hawc.steps.stepfocus.StepFocus.gaussian">[docs]</a>    def gaussian(self, height, center_x, center_y, width_x, width_y, bgoffset):
        &quot;&quot;&quot;
        Return a Gaussian function with the given parameters.

        Parameters
        ----------
        height : float
            Gaussian amplitude.
        center_x : float
            Center x pixel.
        center_y : float
            Center y pixel.
        width_x : float
            Gaussian width, x-direction.
        width_y : float
            Gaussian width, y-direction.
        bgoffset : float
            Background level.

        Returns
        -------
        function
            The Gaussian function.  Arguments are x, y.
        &quot;&quot;&quot;
        width_x = float(width_x)
        width_y = float(width_y)

        def gauss(x, y):
            g = height * np.exp(
                -(((center_x - x) / width_x)**2
                  + ((center_y - y) / width_y)**2) / 2.) + bgoffset
            return g
        return gauss</div>

<div class="viewcode-block" id="StepFocus.moments"><a class="viewcode-back" href="../../../../../api/sofia_redux.instruments.hawc.steps.stepfocus.StepFocus.html#sofia_redux.instruments.hawc.steps.stepfocus.StepFocus.moments">[docs]</a>    def moments(self, data):
        &quot;&quot;&quot;
        Compute Gaussian parameters from moments.

        Parameters
        ----------
        data : array-like
            The image to fit.
        Returns
        -------
        tuple of float
            Elements are the Gaussian parameters for the 2D distribution:
            height, x, y, width_x, width_y, bgoffset.

        &quot;&quot;&quot;
        total = np.nansum(data)
        bgoffset = np.nanmedian(data)
        big_y, big_x = np.indices(data.shape)
        ysize, xsize = data.shape
        if abs(total) == 0:
            total = 1e-7

        x = np.nansum(big_x * data) / total
        y = np.nansum(big_y * data) / total

        log.debug(&quot;Moments: x=%f y=%f tot=%f bgoff=%f&quot; %
                  (x, y, total, float(bgoffset)))

        # If the initial guess for x and y is outside the array,
        # will assume a guess in the center of the image
        # (this situation might happen in case there is no source
        # in the image. The assumption is used to avoid an index
        # problem in the col and row definitions below
        if x &gt;= xsize or x &lt;= 0 or np.isnan(x):
            x = xsize / 2.
        if y &gt;= ysize or y &lt;= 0 or np.isnan(y):
            y = ysize / 2.
        col = data[int(y), :]
        width_x = np.sqrt(np.nansum(abs((np.arange(col.size) - y)**2 * col))
                          / abs(np.nansum(col)))
        row = data[:, int(x)]
        width_y = np.sqrt(np.nansum(abs((np.arange(row.size) - x)**2 * row))
                          / abs(np.nansum(row)))
        height = np.nanmax(data)
        log.debug(&quot;Moments: returning h=%f x=%f y=%f wx=%f wy=%f bg=%f&quot; %
                  (float(height), x, y, width_x, width_y, float(bgoffset)))
        return height, x, y, width_x, width_y, bgoffset</div>

<div class="viewcode-block" id="StepFocus.fitgaussian"><a class="viewcode-back" href="../../../../../api/sofia_redux.instruments.hawc.steps.stepfocus.StepFocus.html#sofia_redux.instruments.hawc.steps.stepfocus.StepFocus.fitgaussian">[docs]</a>    def fitgaussian(self, data, nanpix, medianaverage):
        &quot;&quot;&quot;
        Fit a Gaussian function to an image.

        Parameters
        ----------
        data : array-like
            The image to fit.
        nanpix : array-like
            A mask or index array indicating the positions of NaN pixels.
        medianaverage : bool
            If not set, NaN pixels will be replaced with model values.

        Returns
        -------
        height, x, y, width_x, width_y : tuple of float
            Parameters for a Gaussian fit to the data.
        &quot;&quot;&quot;
        params = list(self.moments(data))
        data_img = data.copy()
        # If medianaverage is False,
        # assume that for bad pixels (NaNs), the value
        # on the array is equal to the model
        # (so that the difference -- errorfunction -- will be zero)
        if not medianaverage:
            model = self.gaussian(*params)(*np.indices(data.shape))
            data_img[nanpix] = model[nanpix]

        # function to fit
        def errorfunction(par):
            return np.ravel(self.gaussian(*par)(*np.indices(data_img.shape))
                            - data_img)

        result = optimize.leastsq(errorfunction, np.array(params))
        amp, centy, centx, widy, widx, offset = result[0]
        success = result[1]

        log.debug(&quot;Fit Values: returning h=%f, x=%f y=%f &quot;
                  &quot;wx=%f wy=%f bg=%f&quot; %
                  (amp, centx, centy, widx, widy, offset))
        return amp, centy, centx, widy, widx, offset, success</div>

<div class="viewcode-block" id="StepFocus.focusplot"><a class="viewcode-back" href="../../../../../api/sofia_redux.instruments.hawc.steps.stepfocus.StepFocus.html#sofia_redux.instruments.hawc.steps.stepfocus.StepFocus.focusplot">[docs]</a>    def focusplot(self, focus, values, difftotfoc,
                  label, lbl, sign, units=&#39;&#39;):
        &quot;&quot;&quot;
        Find and plot the best fit focus value.

        The best focus value is at either the maximum or minimum of
        the `values`, as fit by a 2nd order polynomial.  Plots
        showing the fit and best value are written to disk.

        Parameters
        ----------
        focus : `list` of float
            Focus values (independent variable).
        values : list of float
            Fit values (dependent variable).
        difftotfoc : float
            Mean difference from the total focus offset.
        label : str
            Long label for the plot.
        lbl : str
            Short label for the plot.
        sign : {-1, 1}
            If -1, best fit is at a maximum.  If 1, best fit is at
            a minimum.
        units : str, optional
            Units for the `values`.
        &quot;&quot;&quot;
        # Fit focus curve, find best focus
        #   fit(x) = fit[0]*x**2. + fit[1]*x + fit[2]
        fit = np.polyfit(focus, values, 2)
        xax = np.asarray(np.linspace(min(focus), max(focus), 1000))
        yax = fit[0] * xax**2. + fit[1] * xax + fit[2]
        bestfocx = -fit[1] / (2. * fit[0])

        # Set up plot
        fig = Figure(figsize=(6, 5))
        FigureCanvas(fig)
        ax = fig.add_subplot()
        ax.plot(xax, yax, &#39;r--&#39;, linewidth=3)
        ax.plot(focus, values, &#39;mo&#39;, markersize=10)
        ax.set_xlabel(r&#39;Focus TOTAL offsets ($\mu m$)&#39;)
        ax.set_ylabel(label)

        # bestfocx is a local extremum, but could be a
        # maximum (ideally it would be a minimum).
        # Test to see if there are points in the fit below bestfocx

        # Create a polynomial using the coefficients from fit
        fittest = np.poly1d(fit)

        # Add DEBUG records to the log for the FWHM values
        log.debug(&#39; %s at bestfoc: %.3f %s&#39; %
                  (lbl, fittest(bestfocx), units))

        # Check if extremum is correct
        if fit[0] * sign &lt; 0 or bestfocx &lt; min(focus) or bestfocx &gt; max(focus):
            # Use np.where to find the index
            # of the minimum fwhmx (creates a tuple)
            # Pull the first value from the tuple
            # and use it as an index for focus
            # This raises a warning in the log, but we can ignore it
            valsign = [sign * v for v in values]
            try:
                # It&#39;s possible for
                # np.where(valsign == min(valsign)) to return []
                guessfocx = focus[np.where(valsign == min(valsign))[0]]
            except (IndexError, TypeError):
                log.warning(&#39;Error in focus guess - &#39;
                            &#39;just using first value&#39;)
                guessfocx = focus[0]

            if sign &lt; 0:
                fig.suptitle(&#39;No local maximum found!&#39;, fontsize=12)
                log.warning(&#39;No local maximum found! Best focus &#39;
                            &#39;may be out of analyzed range.&#39;)
            else:
                fig.suptitle(&#39;No local minimum found!&#39;, fontsize=12)
                log.warning(&#39;No local minimum found! Best focus &#39;
                            &#39;may be out of analyzed range.&#39;)

            ax.set_title(&#39;Suggested best focus position &#39;
                         r&#39;(%s): %.1f $\mu m$&#39; %
                         (lbl, guessfocx))
        else:
            # Do this if bestfocx is at the minimum
            ax.set_title(r&#39;Best TOTAL Offset (%s): %.1f $\mu m$ &#39;
                         r&#39;(Absolute Position $\sim$ %.1f $\mu m$)&#39; %
                         (lbl, bestfocx, bestfocx + difftotfoc),
                         fontsize=11)
            log.info(&#39;&#39;)
            log.info(&#39;Best focus position (%s): %.1f um &#39; %
                     (lbl, bestfocx))
            log.info(&#39;  (Look at images and graphs &#39;
                     &#39;to make sure it is a valid minimum!)&#39;)
            log.info(&#39;&#39;)

            # Plot a black &#39;x&#39; on the minimum (just for convenience)
            ax.plot(bestfocx, fittest(bestfocx), &#39;kx&#39;, markersize=10, mew=3)

        # Save image
        pngname = self.datain[-1].filename.replace(
            &#39;.fits&#39;, &#39;_autofocus_%s.png&#39; % lbl.replace(&#39; &#39;, &#39;_&#39;))
        fig.savefig(pngname)
        self.auxout.append(pngname)
        log.info(&#39;Saved result %s&#39; % pngname)</div>

<div class="viewcode-block" id="StepFocus.run"><a class="viewcode-back" href="../../../../../api/sofia_redux.instruments.hawc.steps.stepfocus.StepFocus.html#sofia_redux.instruments.hawc.steps.stepfocus.StepFocus.run">[docs]</a>    def run(self):
        &quot;&quot;&quot;
        Run the data reduction algorithm.

        Because this step is multi-in, multi-out (MIMO),
        self.datain must be a list of DataFits objects.  The output
        is also a list of DataFits objects, stored in self.dataout.

        The process is:

        1. Read in each file, extract an image stamp, and fit
           a Gaussian to it.
        2. From the fit Gaussian parameters for all files, calculate
           the best focus value from: the minimum FWHM (x, y, and
           total), and the maximum Gaussian height.
        &quot;&quot;&quot;
        # Get parameters
        widowisgood = self.getarg(&#39;widowisgood&#39;)
        medianaverage = self.getarg(&#39;medianaverage&#39;)
        boxaverage = self.getarg(&#39;boxaverage&#39;)
        autocrop = self.getarg(&#39;autocrop&#39;)
        cropimage = self.getarg(&#39;cropimage&#39;)
        xyboxcent = list(self.getarg(&#39;xyboxcent&#39;))
        boxsizecrop = self.getarg(&#39;boxsizecrop&#39;)
        primaryimg = self.getarg(&#39;primaryimg&#39;)

        # self.datain must be a list/tuple
        self.nfiles = len(self.datain)
        log.debug(&#39;Analysing %d files&#39; % self.nfiles)

        # counter for the number of images
        nfigs = 1

        # input is set to output, unmodified
        self.dataout = self.datain

        # list to hold output .png names
        self.auxout = []

        amplitude = []
        fwhmx = []
        fwhmy = []
        focus = []
        focus_totoff = []
        srcpeak = []
        srcfwhm = []
        image = None
        for i in range(self.nfiles):
            log.debug(&quot;ANALYZING FILE %d&quot; % (i + 1))

            # If the primary image HDU isn&#39;t specified,
            # use the first image in the file
            if primaryimg == &#39;&#39;:
                try:
                    image = self.datain[i].image.copy()
                except AttributeError:
                    msg = &#39;No image data in file.&#39;
                    log.error(msg)
                    raise ValueError(msg)
                log.debug(&quot;No HDU specified. Using first &quot;
                          &quot;image: %s&quot; % self.datain[i].imgnames[0])
            else:
                # If the HDU is specified, use that image
                image = self.datain[i].imageget(primaryimg).copy()
                log.debug(&quot;Using specified image: %s&quot; % primaryimg)

            # Determine what to use for the bad pixel mask
            if &#39;BAD PIXEL MASK&#39; in self.datain[i].imgnames:
                # Read the bad pixel mask
                badpix = self.datain[i].imageget(&#39;BAD PIXEL MASK&#39;)
                log.debug(&quot;Bad Pixel Mask found&quot;)
            elif &#39;IMAGE MASK&#39; in self.datain[i].imgnames:
                # Read the image mask
                imgmask = self.datain[i].imageget(&#39;IMAGE MASK&#39;)
                log.debug(&quot;Didn&#39;t find Bad Pixel Mask - &quot;
                          &quot;Using Image Mask&quot;)

                # get bad pixel mask, as zero, set to 3 (bad)
                # wherever imgmask==Nan
                badpix = np.zeros_like(imgmask)
                badpix[np.isnan(imgmask)] = 3
            else:
                # If there&#39;s no bad pixel or image mask, use a zero array
                badpix = np.zeros_like(image)
                log.debug(&quot;No Bad Pixel or Image Mask - &quot;
                          &quot;Using zero array&quot;)

            # Autocrop
            if autocrop:
                header = self.datain[i].header
                tempwcs = astwcs.WCS(header)
                ratarget = self.datain[i].getheadval(&#39;CRVAL1&#39;)
                dectarget = self.datain[i].getheadval(&#39;CRVAL2&#39;)
                pix1, pix2 = tempwcs.wcs_world2pix(ratarget, dectarget, 1)
                cropimage = True
                xyboxcent[0] = pix1
                xyboxcent[1] = pix2
                boxsizecrop = np.mean(image.shape) / 3.

            # Option to crop part of the image around a central pixel
            if cropimage:
                x1 = int(xyboxcent[0] - boxsizecrop / 2.)
                x2 = int(xyboxcent[0] + boxsizecrop / 2.)
                y1 = int(xyboxcent[1] - boxsizecrop / 2.)
                y2 = int(xyboxcent[1] + boxsizecrop / 2.)
                if x1 &lt; 0 or x1 &gt; image.shape[1]:
                    x1 = 0
                    log.warning(&#39;Crop box x1 invalid, was set to 0&#39;)
                if y1 &lt; 0 or y1 &gt; image.shape[0]:
                    y1 = 0
                    log.warning(&#39;Crop box y1 invalid, was set to 0&#39;)
                if x2 &lt;= x1 or x2 &gt; image.shape[1]:
                    x2 = image.shape[1]
                    log.warning(&#39;Crop box x2 invalid, was set to width&#39;)
                if y2 &lt;= y1 or y2 &gt; image.shape[0]:
                    y2 = image.shape[0]
                    log.warning(&#39;Crop box y2 invalid, was set to height&#39;)
                image = image[y1:y2, x1:x2]
                badpix = badpix[y1:y2, x1:x2]

            # Select between use widow pixels or use only good pixels
            if widowisgood:
                nanpix = np.where(badpix &gt; 2)
            else:
                nanpix = np.where(badpix != 0)

            # Choose between median average the image
            #  (to get rid of bad pixels)
            # or keep the bad pixels as NaNs in the 2D gaussian fit
            if medianaverage:
                # Assign bad pixels to 0 to allow the box median averaging
                image[nanpix] = 0.
                # Added to make sure there&#39;s no NANs
                image[np.where(image != image)] = 0.
                image = ndimage.filters.uniform_filter(image, size=boxaverage)
            else:
                image[nanpix] = np.nan

            # Fit 2d Gaussian (offset is not used in later code)
            amp, centy, centx, widy, widx, _offset, success = \
                self.fitgaussian(image, nanpix, medianaverage)

            # Append values only if gaussian fit was successful
            if success in [1, 2, 3, 4]:
                fwhmx_img = 2.355 * np.abs(widx)
                fwhmy_img = 2.355 * np.abs(widy)
                amplitude.append(amp)
                fwhmx.append(fwhmx_img)
                fwhmy.append(fwhmy_img)

                # Compute average focus
                focval_st = self.datain[i].getheadval(&#39;FOCUS_ST&#39;)
                focval_en = self.datain[i].getheadval(&#39;FOCUS_EN&#39;)
                focval = np.mean([focval_st, focval_en])
                focus.append(focval)
                if &#39;FCSTOFF&#39; in self.datain[i].header:
                    fcstoff = self.datain[i].getheadval(&#39;FCSTOFF&#39;)
                    focus_totoff.append(fcstoff)
                else:
                    # if no FoCus Total OFFset in the header, copy focval
                    fcstoff = focval
                    focus_totoff.append(focval)
                    log.debug(&#39;FCSTOFF not found; using focus value&#39;)

                # Plotting figure and ellipse around object
                fig = Figure()
                FigureCanvas(fig)
                ax = fig.add_subplot()
                nfigs += 1
                ymax, xmax = image.shape
                ax.imshow(image, cmap=&#39;gray&#39;,
                          extent=[0, xmax - 1, 0, ymax - 1],
                          interpolation=&#39;none&#39;)
                ax.plot(centx, ymax - 1 - centy,
                        &#39;m+&#39;, markersize=15, mew=2)

                ellipse = Ellipse(xy=(centx, ymax - 1 - centy),
                                  width=2.355 * np.abs(widx),
                                  height=2.355 * np.abs(widy),
                                  edgecolor=&#39;b&#39;, fc=&#39;None&#39;, lw=2)
                ax.add_patch(ellipse)
                ax.annotate(&#39;Img %s; Focus: %.1f microns, &#39;
                            &#39;Tot. Off: %.1f microns&#39; %
                            (nfigs - 1, float(focval), fcstoff),
                            xy=(1, 0.95 * ymax), color=&#39;.5&#39;)
                ax.annotate(&#39;Gaussian FWHM X / Y: %.1f / %.1f pixels&#39; %
                            (fwhmx_img, fwhmy_img),
                            xy=(1, 0.90 * ymax), color=&#39;.5&#39;)
                ax.annotate(&#39;Gaussian center X / Y: %.1f / %.1f pixels&#39; %
                            (centx, centy), xy=(1, 1), color=&#39;.5&#39;)
                ax.annotate(&#39;Gaussian height: %1f&#39; % amp,
                            xy=(1, 0.85 * ymax), color=&#39;.5&#39;)

                # Get scanmap estimates (from header of first table)
                dat = self.datain[i]
                try:
                    srcfwhm.append(dat.getheadval(&#39;SRCFWHM&#39;, dat.tabnames[0],
                                                  errmsg=False))
                except (KeyError, IndexError):
                    srcfwhm.append(0)
                try:
                    srcpeak.append(dat.getheadval(&#39;SRCPEAK&#39;, dat.tabnames[0],
                                                  errmsg=False))
                except (KeyError, IndexError):
                    srcpeak.append(0)
            else:
                # unsuccessful gaussian fit
                # Plotting figure and state that the fit was unsuccessful
                fig = Figure()
                FigureCanvas(fig)
                ax = fig.add_subplot()
                nfigs += 1
                ymax, xmax = image.shape
                ax.imshow(image, cmap=&#39;gray&#39;,
                          extent=[0, xmax - 1, 0, ymax - 1],
                          interpolation=&#39;none&#39;)
                ax.annotate(&#39;Gaussian fit was unsuccessful&#39;,
                            xy=(1, ymax - 3), color=&#39;k&#39;)
                log.debug(&#39;Gaussian fit was unsuccessful &#39;
                          &#39;for image {}&#39;.format(i + 1))

            # Save the Plot
            pngname = self.datain[-1].filename.replace(
                &#39;.fits&#39;, &#39;_autofocus_image%s.png&#39; % (nfigs - 1))
            fig.savefig(pngname)
            self.auxout.append(pngname)
            log.info(&#39;Saved result %s&#39; % pngname)

        # Calculate difference between focus and focus_totoff
        difftotfoc = float(np.mean(np.asarray(focus)[:]
                                   - np.asarray(focus_totoff)[:]))

        # At least 3 successful gaussian fits are required
        # to attempt a parabolic fit of FWHM x Focus
        # Also attempt a fit for Gaussian height
        if len(focus_totoff) &gt;= 3:
            # FWHM x Focus for X
            self.focusplot(focus_totoff, fwhmx, difftotfoc,
                           &#39;FWHM Along X Axis (pix)&#39;,
                           &#39;FWHM X&#39;, 1, units=&#39;pix&#39;)

            # FWHM x Focus for Y
            self.focusplot(focus_totoff, fwhmy, difftotfoc,
                           &#39;FWHM Along Y Axis (pix)&#39;,
                           &#39;FWHM Y&#39;, 1, units=&#39;pix&#39;)

            # FWHM x Focus for XY
            self.focusplot(focus_totoff + focus_totoff,
                           fwhmx + fwhmy, difftotfoc,
                           &#39;FWHM Along X and Y Axis (pix)&#39;,
                           &#39;FWHM XY&#39;, 1, units=&#39;pix&#39;)

            # Focus for Gaussian Height
            try:
                imgunit = self.datain[0].header[&#39;BUNIT&#39;]
            except KeyError:
                imgunit = &#39;Img Units&#39;
            self.focusplot(focus_totoff, amplitude, difftotfoc,
                           &#39;Gaussian Height ({})&#39;.format(imgunit),
                           &#39;Amplitude&#39;, -1, units=imgunit)

            # Select only data with valid inputs
            # (i.e. srcpeak not zero)
            srcn = len(srcpeak)
            srcfoc = [focus_totoff[i]
                      for i in range(srcn) if srcpeak[i] != 0]
            srcp = [srcpeak[i] for i in range(srcn) if srcpeak[i] != 0]
            srcselfwhm = [srcfwhm[i]
                          for i in range(srcn) if srcpeak[i] != 0]
            if len(srcfoc) &gt; 0:
                # Focus from Scanmap Peak/Int
                self.focusplot(srcfoc, srcp, difftotfoc,
                               &#39;Peak from scan map fit ({})&#39;.format(imgunit),
                               &#39;Peak&#39;, -1, units=imgunit)
                # Focus from Scanmap FWHM
                self.focusplot(srcfoc, srcselfwhm, difftotfoc,
                               &#39;FWHM from scan map fit (arcsec)&#39;,
                               &#39;FWHM-C&#39;, 1, units=&#39;arcsec&#39;)
            else:
                log.debug(&#39;Scan map fit keys not found.&#39;)

        elif image is not None:
            # Plotting last figure again and state that
            # there are not enough points for parabolic fit
            fig = Figure()
            FigureCanvas(fig)
            ax = fig.add_subplot()
            ymax, xmax = image.shape
            ax.imshow(image, cmap=&#39;gray&#39;, extent=[0, xmax - 1, 0, ymax - 1],
                      interpolation=&#39;none&#39;)
            ax.annotate(&#39;There are not enough successful&#39;,
                        xy=(1, ymax - 5), color=&#39;w&#39;)
            ax.annotate(&#39;Gaussian fits to fit a parabola (minimum 3)&#39;,
                        xy=(1, ymax - 9), color=&#39;w&#39;)
            log.info(&#39;There are not enough successful Gaussian &#39;
                     &#39;fits to fit a parabola (minimum 3)&#39;)
            pngname = self.datain[-1].filename.replace(
                &#39;.fits&#39;, &#39;_autofocus_xyaxis.png&#39;)
            fig.savefig(pngname)
            self.auxout.append(pngname)
            log.info(&#39;Saved result %s&#39; % pngname)</div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2023, SOFIA-USRA.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 7.1.2. &nbsp;
    Last built 13 Aug 2023. <br/>
  </p>
</footer>
  </body>
</html>