<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sofia_redux.scan.configuration.conditions &#8212; sofia_redux v1.3.4.dev0</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/bootstrap-sofia.css?v=3fe2c07e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    
    <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js?v=602f4d50"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script type="text/javascript" src="../../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../../_static/copybutton.js"></script>
    <link rel="icon" href="../../../../_static/redux.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../../index.html"><span id="logotext1">SOFIA</span><span id="logotext2">Redux</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="SOFIA Homepage" href="https://www.sofia.usra.edu/"></a></li>
    <li><a title="General Index" href="../../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../../index.html">sofia_redux v1.3.4.dev0</a>
	 &#187;
      </li>
      <li><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sofia_redux.scan.configuration.conditions</h1><div class="highlight"><pre>
<span></span># Licensed under a 3-clause BSD style license - see LICENSE.rst

import configobj
import re

from sofia_redux.scan.configuration.options import Options

__all__ = [&#39;Conditions&#39;]


<div class="viewcode-block" id="Conditions"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.configuration.conditions.Conditions.html#sofia_redux.scan.configuration.conditions.Conditions">[docs]</a>class Conditions(Options):

    append_keys = (&#39;blacklist&#39;, &#39;whitelist&#39;, &#39;forget&#39;, &#39;recall&#39;,
                   &#39;lock&#39;, &#39;unlock&#39;, &#39;add&#39;, &#39;config&#39;)

    def __init__(self, allow_error=False, verbose=True):
        &quot;&quot;&quot;
        Initialize the configuration conditions.

        The configuration conditions are a set of requirements to check for in
        the configuration, and actions to perform if those conditions are met.
        Processing conditions is generally a recursive operation since applying
        actions may subsequently trigger other condition requirements.

        Parameters
        ----------
        allow_error : bool, optional
            If `True`, allow poorly formatted options to be skipped rather than
            raising an error.
        verbose : bool, optional
            If `True`, issues a warning when a poorly option is encountered.
        &quot;&quot;&quot;
        super().__init__(allow_error=allow_error, verbose=verbose)

    def __len__(self):
        &quot;&quot;&quot;
        Return the number of conditions available.

        Returns
        -------
        int
        &quot;&quot;&quot;
        if not hasattr(self.options, &#39;__len__&#39;):
            return 0
        return len(self.options)

    def __setitem__(self, requirement, options):
        &quot;&quot;&quot;
        Set the options for a given requirement.

        Parameters
        ----------
        requirement : str
            The requirement for the condition to be met.  Should be of the form
            &lt;key&gt;&lt;operator&gt;&lt;value&gt;.
        options : str or dict or configobj.ConfigObj
            The options to apply once the condition is met.  If a single string
            is provided, it should be of the form {&lt;command_or_key&gt;=&lt;value&gt;} or
            &lt;value&gt;.  If only &lt;value&gt; is provided, the associated command will
            be changed to add=&lt;value&gt;.

        Returns
        -------
        None
        &quot;&quot;&quot;
        self.set(requirement, options)

    def __str__(self):
        &quot;&quot;&quot;
        Return a string representation of the configuration.

        Returns
        -------
        str
        &quot;&quot;&quot;
        size = self.size
        return f&#39;Contains {size} condition{&quot;s&quot; if size != 1 else &quot;&quot;}.&#39;

    def __repr__(self):
        &quot;&quot;&quot;
        Return a string representation of the configuration.

        Returns
        -------
        str
        &quot;&quot;&quot;
        return super().__repr__() + f&#39; {self}&#39;

    @property
    def size(self):
        &quot;&quot;&quot;
        Return the number of conditions available.

        Returns
        -------
        int
        &quot;&quot;&quot;
        return self.__len__()

<div class="viewcode-block" id="Conditions.copy"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.configuration.conditions.Conditions.html#sofia_redux.scan.configuration.conditions.Conditions.copy">[docs]</a>    def copy(self):
        &quot;&quot;&quot;
        Return a copy of the conditions.

        Returns
        -------
        Conditions
        &quot;&quot;&quot;
        return super().copy()</div>

<div class="viewcode-block" id="Conditions.set"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.configuration.conditions.Conditions.html#sofia_redux.scan.configuration.conditions.Conditions.set">[docs]</a>    def set(self, requirement, options):
        &quot;&quot;&quot;
        Set a condition in the options.

        Parameters
        ----------
        requirement : str
           Typically a requirement of the form key=value.
        options : dict or ConfigObj
           The options to apply if the condition is met.

        Returns
        -------
        None
        &quot;&quot;&quot;
        condition_options = self.options_to_dict(options)
        if condition_options is None:
            self.handle_error(f&quot;Could not parse condition &quot;
                              f&quot;[{requirement}]: {options}&quot;)
            return

        if requirement not in self.options:
            self.options[requirement] = configobj.ConfigObj()

        self.merge_options(self.options[requirement], condition_options)</div>

<div class="viewcode-block" id="Conditions.update"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.configuration.conditions.Conditions.html#sofia_redux.scan.configuration.conditions.Conditions.update">[docs]</a>    def update(self, configuration_options):
        &quot;&quot;&quot;
        Update the stored conditions with those from another configuration.

        Parameters
        ----------
        configuration_options : dict or ConfigObj
            The configuration options to read and parse.

        Returns
        -------
        None
        &quot;&quot;&quot;
        if &#39;conditionals&#39; not in configuration_options:
            return
        options = configuration_options[&#39;conditionals&#39;]
        if not isinstance(options, dict):
            self.handle_error(f&quot;Supplied conditionals must be {dict} type.&quot;)
            return

        for key, value in options.items():
            self.set(key, value)</div>

<div class="viewcode-block" id="Conditions.check_requirement"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.configuration.conditions.Conditions.html#sofia_redux.scan.configuration.conditions.Conditions.check_requirement">[docs]</a>    def check_requirement(self, configuration, requirement):
        r&quot;&quot;&quot;
        Checks requirements and returns if met

        Conditions must be of the form &lt;thing&gt;&lt;operator&gt;&lt;required_value&gt;,
        where operator must be one of &#39;=&#39;, &#39;!=&#39;, &#39;&lt;&#39;, &#39;&lt;=&#39;, &#39;&gt;&#39;, &#39;&gt;=&#39;.

        Alternatively, a single value may be supplied.  If set in the
        configuration, True is returned

        Parameters
        ----------
        configuration : Configuration
            The configuration in which to check the requirement.
        requirement : str
            The requirement to check.

        Returns
        -------
        bool
        &quot;&quot;&quot;
        if re.search(r&#39;(?&lt;![&lt;!&gt;])=&#39;, requirement):  # equals
            operator = &#39;=&#39;
        elif re.search(r&#39;&lt;(?!=)&#39;, requirement):  # less than
            operator = &#39;&lt;&#39;
        elif re.search(r&#39;&gt;(?!=)&#39;, requirement):  # greater than
            operator = &#39;&gt;&#39;
        elif &#39;!=&#39; in requirement:
            operator = &#39;!=&#39;
        elif &#39;&lt;=&#39; in requirement:
            operator = &#39;&lt;=&#39;
        elif &#39;&gt;=&#39; in requirement:
            operator = &#39;&gt;=&#39;
        else:
            operator = None

        # If there is no operator, assume it is a boolean switch.
        if operator is None:
            return configuration.get_bool(requirement.strip(), default=False)

        s = [s.strip() for s in requirement.split(operator)]
        s = [x for x in s if x != &#39;&#39;]
        if len(s) != 2:
            self.handle_error(f&quot;Bad conditional requirement: {requirement}&quot;)
            return False

        key, test_value = s
        value = configuration.get(key, default=None)
        if value is None:
            return False

        value = str(value).strip()

        if operator == &#39;=&#39; or operator == &#39;==&#39;:
            try:
                value = float(value)
                test_value = float(test_value)
                return value == test_value
            except (ValueError, TypeError):
                return value == test_value

        if operator == &#39;!=&#39;:
            try:
                value = float(value)
                test_value = float(test_value)
                return value != test_value
            except (ValueError, TypeError):
                return value != test_value

        try:
            value = float(value)
            test_value = float(test_value)
        except (ValueError, TypeError):
            return False

        try:
            return eval(&#39;%f %s %f&#39; % (value, operator, test_value))
        except (ValueError, TypeError):  # pragma: no cover
            return False</div>

<div class="viewcode-block" id="Conditions.get_met_conditions"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.configuration.conditions.Conditions.html#sofia_redux.scan.configuration.conditions.Conditions.get_met_conditions">[docs]</a>    def get_met_conditions(self, configuration):
        &quot;&quot;&quot;
        Return the actions for met conditions.

        Check a configuration with all conditions and return those that are
        fulfilled.  Conditions in the options that follow the standard
        format of {requirement (str): actions (dict)} will have the requirement
        checked with the configuration.  However, condition options that are of
        the form {requirement (str): actions (str)} will always be parsed
        assuming that the requirement is met due to the complexities of the
        configuration structure and always returned in the output options.

        Parameters
        ----------
        configuration : Configuration

        Returns
        -------
        actions : dict
            A dict of form {requirement: actions}.
        &quot;&quot;&quot;
        apply_actions = {}
        for requirement, actions in self.options.items():

            if isinstance(actions, dict):
                requirement_met = self.check_requirement(
                    configuration, requirement)
            else:
                # in rare instances there is no requirement
                requirement_met = True
                s = [s.strip() for s in actions.split(&#39;=&#39;)]
                s = [x for x in s if x != &#39;&#39;]
                if len(s) != 2:
                    self.handle_error(f&quot;Bad condition: {actions}&quot;)
                    continue
                actions = {s[0]: s[1]}

            if not requirement_met:
                continue

            if requirement not in apply_actions:
                apply_actions[requirement] = []

            requirement_actions = apply_actions[requirement]
            if actions not in requirement_actions:
                requirement_actions.append(actions)

        return apply_actions</div>

<div class="viewcode-block" id="Conditions.process_conditionals"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.configuration.conditions.Conditions.html#sofia_redux.scan.configuration.conditions.Conditions.process_conditionals">[docs]</a>    def process_conditionals(self, configuration, seen=None):
        &quot;&quot;&quot;
        Process all conditions until no further changes are required.

        Parameters
        ----------
        configuration : Configuration
        seen : set, optional
            A set of previously applied conditions and actions.  Each member
            should be a tuple of the form (requirement, command, action).

        Returns
        -------
        None
        &quot;&quot;&quot;
        if seen is None:
            seen = set([])
        while self.update_configuration(configuration, seen=seen):
            pass</div>

<div class="viewcode-block" id="Conditions.update_configuration"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.configuration.conditions.Conditions.html#sofia_redux.scan.configuration.conditions.Conditions.update_configuration">[docs]</a>    def update_configuration(self, configuration, seen=None):
        &quot;&quot;&quot;
        Update the configuration with any met conditions.

        Parameters
        ----------
        configuration : Configuration
        seen : set, optional
            A set of previously applied conditions and actions

        Returns
        -------
        updated : bool
            `True` if the configuration was updated, and `False` otherwise.
        &quot;&quot;&quot;
        if seen is None:
            seen = set([])

        apply_actions = self.get_met_conditions(configuration)
        if len(apply_actions) == 0:
            return False

        contains_update = False
        for requirement, actions in apply_actions.items():
            configuration.applied_conditions.add(requirement)

            commands = {}

            for action in actions:
                for key, value in action.items():
                    str_val = str(value)
                    check_command = (requirement, key, str_val)
                    if check_command in seen:
                        continue
                    contains_update = True
                    seen.add(check_command)

                    if key in configuration.command_keys:
                        if key in commands:
                            commands[key].append(value)  # pragma: no cover
                        else:
                            commands[key] = [value]
                    else:
                        if &#39;update&#39; not in commands:
                            commands[&#39;update&#39;] = {key: value}
                        else:
                            commands[&#39;update&#39;][key] = value

            configuration.apply_commands(commands)

        return contains_update</div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2023, SOFIA-USRA.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 7.1.2. &nbsp;
    Last built 13 Aug 2023. <br/>
  </p>
</footer>
  </body>
</html>