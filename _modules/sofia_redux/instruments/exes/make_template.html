<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sofia_redux.instruments.exes.make_template &#8212; sofia_redux v1.3.4.dev0</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/bootstrap-sofia.css?v=3fe2c07e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    
    <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js?v=602f4d50"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script type="text/javascript" src="../../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../../_static/copybutton.js"></script>
    <link rel="icon" href="../../../../_static/redux.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../../index.html"><span id="logotext1">SOFIA</span><span id="logotext2">Redux</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="SOFIA Homepage" href="https://www.sofia.usra.edu/"></a></li>
    <li><a title="General Index" href="../../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../../index.html">sofia_redux v1.3.4.dev0</a>
	 &#187;
      </li>
      <li><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sofia_redux.instruments.exes.make_template</h1><div class="highlight"><pre>
<span></span># Licensed under a 3-clause BSD style license - see LICENSE.rst

from astropy import log
import numpy as np

from sofia_redux.instruments.exes import utils

__all__ = [&#39;make_template&#39;]


<div class="viewcode-block" id="make_template"><a class="viewcode-back" href="../../../../api/sofia_redux.instruments.exes.make_template.make_template.html#sofia_redux.instruments.exes.make_template.make_template">[docs]</a>def make_template(data, header, weighting_frame,
                  weights=None, illum=None, good_frames=None,
                  collapsed=False):
    &quot;&quot;&quot;
    Make a spectral template for weighting and shifting spectra.

    Good frames are weighted by 1/weighting_frame^2 and averaged
    together, then the resulting frame is averaged in the spectral
    direction, and replicated over the spectral elements. The result
    is an average spatial profile that can be cross-correlated with
    individual 2D spectral frames, to determine spatial shifts
    or coadd weighting.

    Parameters
    ----------
    data : numpy.ndarray
        3D data cube [nframe, ny, nx].  Input data is assumed to
        be distortion corrected and rotated as needed to align the spectral
        direction along the x-axis.
    header : Header
        FITS header associated with the data.
    weighting_frame : numpy.ndarray
        Weighting frame (eg. flat or uncertainty image). May be a single
        2D frame [ny, nx] to apply to all frames or a 3D
        cube [nframe, ny, nx].
    weights : numpy.ndarray
        1D array [nframe] of weights to use for input frames. If
        weight=0, frame will be skipped.
    illum : numpy.ndarray
        2D array [ny, nx] indicates illuminated regions of
        the frame. 1 = illuminated, 0 = unilluminated, -1 = pixel that
        does not correspond to any region in the raw frame (before
        undistortion).
    good_frames : numpy.ndarray, optional
        1D array of indices of good frames. If provided, any frame not in
        `good_frames` will be skipped.
    collapsed : bool, optional
        If set, the average template collapsed along the spectral dimension
        will be returned instead of the full 2D array.

    Returns
    -------
    template : numpy.ndarray
        2D spatial template [ny, nx], or 1D [ny] if
        `collapsed` is set.
    &quot;&quot;&quot;
    nx = header.get(&#39;NSPAT&#39;)
    ny = header.get(&#39;NSPEC&#39;)
    shape = (ny, nx)

    try:
        nz = utils.check_data_dimensions(data=data, nx=nx, ny=ny)
    except RuntimeError:
        log.error(f&#39;Data has wrong dimensions {data.shape}. &#39;
                  f&#39;Not making template&#39;)
        return None

    if weighting_frame.ndim &lt;= 2:
        weighting_frame = np.repeat(weighting_frame[np.newaxis, :], nz, axis=0)

    if weights is None:
        weights = np.ones(nz)
    if illum is None:
        illum = np.ones((ny, nx))

    log.info(&#39;Making spatial template.&#39;)
    try:
        z_weight_sum = _weight_good_frames(good_frames, weights, nz)
    except RuntimeError as msg:
        log.error(msg)
        return None

    try:
        z_good, weight_mask = _good_data_points(illum, weighting_frame,
                                                shape, weights)
    except RuntimeError as msg:
        log.error(msg)
        return None

    # Average array in z
    if nz &gt; 1:
        idx = np.isnan(data)
        masked_data = np.ma.MaskedArray(data, mask=idx)
        z_avg = np.ma.average(masked_data, weights=weight_mask, axis=0)
        z_avg = np.ma.filled(z_avg, fill_value=np.nan)
        z_weight_frame = np.nansum(np.abs(weight_mask), axis=0) / z_weight_sum
    else:
        z_avg = data * weight_mask / z_weight_sum
        z_weight_frame = np.abs(weight_mask) / z_weight_sum

    template = _create_template_image(z_good, z_avg, nx, ny, z_weight_frame,
                                      collapsed)

    return template</div>


def _weight_good_frames(good_frames, weights, nz):
    &quot;&quot;&quot;Weight frames according to input.&quot;&quot;&quot;

    # check which frames are good
    all_frames = np.arange(nz)
    if good_frames is None or len(good_frames) == 0:
        good_frames = all_frames.copy()
    _, suball, subgood = np.intersect1d(all_frames, good_frames,
                                        return_indices=True)
    if len(suball) == 0:
        raise RuntimeError(&#39;No good frames. Not making templates.&#39;)

    # weight good frames equally if not provided
    if weights is None or len(weights) != nz:
        weights = np.zeros(nz)
        weights[suball] = 1

    # set weights to zero for any bad frames
    for i in range(nz):
        if i not in suball:
            weights[i] = 0

    z_weight_sum = np.sum(np.abs(weights))
    return z_weight_sum


def _good_data_points(illum, weighting_frame, shape, weights):
    &quot;&quot;&quot;Get good data points from weighting frame or illumination mask.&quot;&quot;&quot;
    good_idx = (illum == 1) &amp; (weighting_frame &gt; 0)
    if good_idx.sum() == 0:
        raise RuntimeError(&#39;No good data points. Not making template.&#39;)

    if np.sum(~good_idx) &gt; 0:
        # Avoid dividing by zero
        c_weighting_frame = weighting_frame.copy()
        c_weighting_frame[~good_idx] = 1.
        weighting_frame_weight = 1 / c_weighting_frame ** 2
        weighting_frame_weight[~good_idx] = 0.
    else:
        weighting_frame_weight = 1 / weighting_frame ** 2

    z_good = np.ones(shape, dtype=bool)
    weight_mask = (weights * (good_idx.astype(float)
                              * weighting_frame_weight.astype(float)).T).T
    z_good = np.all(np.vstack((z_good[None], good_idx)), axis=0)
    if weight_mask.shape[0] == 1:
        weight_mask = weight_mask[0]

    return z_good, weight_mask


def _create_template_image(z_good, z_avg, nx, ny, z_weight_frame, collapsed):
    &quot;&quot;&quot;Collapse and replicate template spectrally (over x).&quot;&quot;&quot;
    # Note: this assumes undistortion (tort) has been performed previously
    # and cross-dispersed data have been rotated to align the spectral
    # direction with the x-axis
    template = np.zeros((ny, nx))
    illsum = np.nansum(z_good, axis=1)
    ysum = np.nansum(z_avg, axis=1)

    idx = illsum &gt; ny / 2
    if np.sum(idx) == 0:
        log.error(&#39;No good data points. Not making template.&#39;)
        return None

    flat_weight_sum = np.nansum(z_weight_frame, axis=1)
    template_col = np.zeros(ny)
    template_col[idx] = ysum[idx] / flat_weight_sum[idx]

    if collapsed:
        return template_col

    template[:] = template_col[:, None]
    template[z_good != 1] = 0

    return template
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2023, SOFIA-USRA.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 7.1.2. &nbsp;
    Last built 13 Aug 2023. <br/>
  </p>
</footer>
  </body>
</html>