<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sofia_redux.scan.filters.filter &#8212; sofia_redux v1.3.4.dev0</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/bootstrap-sofia.css?v=3fe2c07e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    
    <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js?v=602f4d50"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script type="text/javascript" src="../../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../../_static/copybutton.js"></script>
    <link rel="icon" href="../../../../_static/redux.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../../index.html"><span id="logotext1">SOFIA</span><span id="logotext2">Redux</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="SOFIA Homepage" href="https://www.sofia.usra.edu/"></a></li>
    <li><a title="General Index" href="../../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../../index.html">sofia_redux v1.3.4.dev0</a>
	 &#187;
      </li>
      <li><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sofia_redux.scan.filters.filter</h1><div class="highlight"><pre>
<span></span># Licensed under a 3-clause BSD style license - see LICENSE.rst

from abc import ABC, abstractmethod
from astropy.stats import gaussian_sigma_to_fwhm
from copy import deepcopy
import numpy as np
import scipy

from sofia_redux.scan.utilities import numba_functions
from sofia_redux.scan.channels.channels import Channels
from sofia_redux.scan.channels.channel_data.channel_data import ChannelData
from sofia_redux.scan.channels.channel_group.channel_group import ChannelGroup
from sofia_redux.scan.filters import filters_numba_functions as fnf

__all__ = [&#39;Filter&#39;]


<div class="viewcode-block" id="Filter"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter">[docs]</a>class Filter(ABC):

    def __init__(self, integration=None, data=None):
        &quot;&quot;&quot;
        Initialize an integration filter.

        The filter is designed to filter integration data using an FFT.
        This is an abstract class designed to hold a few main parameters
        necessary for filtering.  Each filter requires an integration on
        which to operate, and defines a response at any given frequency.

        Parameters
        ----------
        integration : Integration, optional
        data : numpy.ndarray (float), optional
            An array of shape (nt, n_channels) where nt is the nearest
            power of 2 integer above the number of integration frames. i.e.,
            if n_frames=5, nt=8, or if n_frames=13, nt=16.
        &quot;&quot;&quot;
        self.integration = None
        self.channels = None
        self.parms = None  # The integration filter dependents
        self.frame_parms = None  # Frame dependents
        self.data = None  # Temporary or real filter data workspace
        self.points = None  # frame relative weight sums for each channel
        self.is_sub_filter = False  # Whether this is a sub-filter of main

        self.nt = 0   # pow2ceil of integration.size
        self.nf = 0   # The Nyquist frequency index
        self.df = 0.0  # The frequency spacing

        self.dft = False   # Whether to use the discrete Fourier transform
        self.pedantic = False  # If True, level filter data after application
        self.enabled = False   # Whether the filter is enabled in the config

        if data is not None:
            self.data = data

        if integration is not None:
            self.set_integration(integration)

<div class="viewcode-block" id="Filter.copy"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.copy">[docs]</a>    def copy(self):
        &quot;&quot;&quot;
        Return a copy of the filter.

        All attributes are copied aside from the integration and channels which
        are referenced only.

        Returns
        -------
        Filter
        &quot;&quot;&quot;
        new = self.__class__(integration=None, data=None)
        for attribute, value in self.__dict__.items():
            if attribute in self.referenced_attributes:
                setattr(new, attribute, value)
            elif hasattr(value, &#39;copy&#39;):
                setattr(new, attribute, value.copy())
            else:
                setattr(new, attribute, deepcopy(value))
        return new</div>

    @property
    def referenced_attributes(self):
        &quot;&quot;&quot;
        Return attributes that should be referenced during the copy operation.

        Returns
        -------
        set (str)
        &quot;&quot;&quot;
        return {&#39;integration&#39;, &#39;channels&#39;}

    @property
    def channel_dependent_attributes(self):
        &quot;&quot;&quot;
        Return attributes that are dependent on the parent channels.

        This is required during a slim operation (reducing number of channels)
        which may happen to the filter integration.

        Returns
        -------
        set (str)
        &quot;&quot;&quot;
        return {&#39;points&#39;}

    @property
    def size(self):
        &quot;&quot;&quot;
        Return the number of integration frames.

        Returns
        -------
        n_frames : int
        &quot;&quot;&quot;
        if self.frames is None:
            return 0
        return self.frames.size

    @property
    def channel_size(self):
        &quot;&quot;&quot;
        Return the number of channels in the filter.

        Returns
        -------
        n_channels : int
        &quot;&quot;&quot;
        if self.channels is None:
            return 0
        return self.channels.size

    @property
    def frames(self):
        &quot;&quot;&quot;
        Return the integration frames.

        Returns
        -------
        Frames
        &quot;&quot;&quot;
        if self.integration is None:
            return None
        return self.integration.frames

    @property
    def info(self):
        &quot;&quot;&quot;
        Return the integration information.

        Returns
        -------
        Info
        &quot;&quot;&quot;
        if self.integration is None:
            return None
        return self.integration.info

    @property
    def configuration(self):
        &quot;&quot;&quot;
        Return the configuration (taken from the integration).

        Returns
        -------
        Configuration
        &quot;&quot;&quot;
        if self.integration is None:
            return None
        return self.integration.configuration

    @property
    def flagspace(self):
        &quot;&quot;&quot;
        Return the frame flagspace.

        Returns
        -------
        Flags
        &quot;&quot;&quot;
        if self.integration is None:
            return None
        return self.integration.frames.flagspace

    @property
    def channel_flagspace(self):
        &quot;&quot;&quot;
        Return the channel flagspace.

        Returns
        -------
        Flags
        &quot;&quot;&quot;
        if self.channels is None:
            return None
        return self.channels.flagspace

    @property
    def valid_filtering_frames(self):
        &quot;&quot;&quot;
        Return frames that are valid and not flagged as modeling.

        Returns
        -------
        valid_frames : numpy.ndarray (bool)
            An array of shape (n_frames,) where `True` marks a valid frame to
            be included in filtering operations.
        &quot;&quot;&quot;
        if self.frames is None:
            return np.empty(0, dtype=bool)
        return self.frames.is_unflagged(
            self.flagspace.flags.MODELING_FLAGS) &amp; self.frames.valid

<div class="viewcode-block" id="Filter.reindex"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.reindex">[docs]</a>    def reindex(self):
        &quot;&quot;&quot;Reindex the channel groups to be consistent with parent channels.

        When the channels in the filter integration change for some reason
        (such as a slim operation in which bad channels are removed), filter
        attributes that map to integration channels will also need to be
        updated to account for such a change.

        At a base level, the filter attributes that need to be updated include
        channel dependents, and the `points` (sum of frame weights) for
        each channel.  The `data` attribute is also set to `None`, since it
        is designed to be a temporary workspace that may or may not depend on
        the integration channels depending on the type of filter in question.
        &quot;&quot;&quot;
        if self.channels is None:
            return

        self.data = None

        keep_indices = self.channels.new_indices_in_old()
        self.channels.reindex()

        if self.parms is not None:
            self.parms = self.integration.get_dependents(
                self.get_config_name())

        channel_attributes = self.channel_dependent_attributes

        for attribute, value in self.__dict__.items():
            if attribute not in channel_attributes:
                continue
            if not isinstance(value, np.ndarray):
                continue
            setattr(self, attribute, value[keep_indices])</div>

<div class="viewcode-block" id="Filter.has_option"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.has_option">[docs]</a>    def has_option(self, key):
        &quot;&quot;&quot;
        Return whether an option is set in the configuration for this filter.
        The actual key checked for in the configuration will be:

           &lt;filter_config_name&gt;.&lt;key&gt;

        I.e., the &quot;level&quot; key for a whitening filter will be checked for in the
        configuration as  &quot;filter.whiten.level&quot;.

        Parameters
        ----------
        key : str
            The name of the option for the filter.

        Returns
        -------
        is_configured : bool
        &quot;&quot;&quot;
        if self.integration is None:
            return False
        return self.integration.has_option(f&#39;{self.get_config_name()}.{key}&#39;)</div>

<div class="viewcode-block" id="Filter.option"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.option">[docs]</a>    def option(self, key):
        &quot;&quot;&quot;
        Return the value for a given filter option.

        The given `key` relates specifically to this filter in the
        configuration.  As such, the actual configuration will search for the
        configuration value associated with &lt;filter_config_name&gt;.&lt;key&gt;.  I.e.,
        the &quot;level&quot; key for a whitening filter will be checked for in the
        configuration as &quot;filter.whiten.level&quot;.

        Parameters
        ----------
        key : str
            The name of the option for the filter.

        Returns
        -------
        str
        &quot;&quot;&quot;
        if self.integration is None:
            return None
        return self.configuration.get(f&#39;{self.get_config_name()}.{key}&#39;)</div>

<div class="viewcode-block" id="Filter.make_temp_data"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.make_temp_data">[docs]</a>    def make_temp_data(self, channels=None):
        &quot;&quot;&quot;
        Create the initial temporary data.

        Creates a temporary data array of shape (n_channels, n_frames).

        Parameters
        ----------
        channels : ChannelGroup, optional
            The channels for which to create the temporary data.  If not
            supplied, defaults to the filtering channels.

        Returns
        -------
        None
        &quot;&quot;&quot;
        if self.data is not None:
            self.data = None
            self.points = None
        if channels is None:
            channels = self.get_channels()

        filter_size = numba_functions.pow2ceil(self.integration.size)
        n_channels = channels.size
        self.data = np.zeros((n_channels, filter_size), dtype=float)
        self.points = np.zeros(n_channels, dtype=float)</div>

<div class="viewcode-block" id="Filter.discard_temp_data"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.discard_temp_data">[docs]</a>    def discard_temp_data(self):
        &quot;&quot;&quot;
        Destroy the temporary data.

        Returns
        -------
        None
        &quot;&quot;&quot;
        self.data = None
        self.points = None</div>

<div class="viewcode-block" id="Filter.is_enabled"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.is_enabled">[docs]</a>    def is_enabled(self):
        &quot;&quot;&quot;
        Return whether the filter is enabled.

        Returns
        -------
        bool
        &quot;&quot;&quot;
        return self.enabled</div>

<div class="viewcode-block" id="Filter.get_temp_data"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.get_temp_data">[docs]</a>    def get_temp_data(self):
        &quot;&quot;&quot;
        Return the temporary data.

        Returns
        -------
        numpy.ndarray (float)
        &quot;&quot;&quot;
        return self.data</div>

<div class="viewcode-block" id="Filter.set_temp_data"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.set_temp_data">[docs]</a>    def set_temp_data(self, data):
        &quot;&quot;&quot;
        Set the temporary data.

        Parameters
        ----------
        data : numpy.ndarray (float)

        Returns
        -------
        None
        &quot;&quot;&quot;
        self.data = data</div>

<div class="viewcode-block" id="Filter.rejection_at"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.rejection_at">[docs]</a>    def rejection_at(self, fch):
        &quot;&quot;&quot;
        Return the filter rejection at given frequency channel(s).

        The filter rejection is equal to 1 minus the filter response:

            rejection = 1 - response

        Parameters
        ----------
        fch : int or numpy.ndarray (int or bool) or slice.

        Returns
        -------
        response : float or numpy.ndarray (float)
        &quot;&quot;&quot;
        return 1.0 - self.response_at(fch)</div>

<div class="viewcode-block" id="Filter.count_parms"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.count_parms">[docs]</a>    def count_parms(self):
        &quot;&quot;&quot;
        Return the total dependent count of the filter.

        The number of filter dependents is calculated as the sum of the
        filter rejection (varies from 0 to 1) between the high-pass and
        Nyquist frequency (inclusive).

        Returns
        -------
        rejected : float or numpy.ndarray (float)
            The sum of the rejected signal above the high pass frequency.  If
            this is a filter that varies by channel, an array will be returned
            of shape (n_channels,).  Otherwise, a singular float value will be
            returned.
        &quot;&quot;&quot;
        min_freq = self.get_high_pass_index()
        rejection = self.rejection_at(np.arange(min_freq, self.nf))
        if rejection.ndim &lt; 2:
            return np.sum(rejection)
        else:
            return np.sum(rejection, axis=1)</div>

<div class="viewcode-block" id="Filter.get_channels"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.get_channels">[docs]</a>    def get_channels(self):
        &quot;&quot;&quot;
        Return the associated channel group for the integration filter.

        Returns
        -------
        ChannelGroup
        &quot;&quot;&quot;
        return self.channels</div>

<div class="viewcode-block" id="Filter.set_channels"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.set_channels">[docs]</a>    def set_channels(self, channels):
        &quot;&quot;&quot;
        Set the filter channels.

        The channels attribute will be set to a ChannelGroup type.

        Parameters
        ----------
        channels : Channels or ChannelData or ChannelGroup

        Returns
        -------
        None
        &quot;&quot;&quot;
        if channels is None:
            self.channels = None
            return
        if isinstance(channels, Channels):
            self.channels = channels.create_channel_group(name=&#39;all&#39;)
        elif isinstance(channels, ChannelData):
            if not isinstance(channels, ChannelGroup):
                group_class = self.info.get_channel_group_class()
                self.channels = group_class(
                    channels, indices=np.arange(channels.size), name=&#39;all&#39;)
            else:
                self.channels = channels.copy()
        else:
            raise ValueError(f&quot;Channels must be {Channels} or {ChannelData}, &quot;
                             f&quot;not {channels}.&quot;)</div>

<div class="viewcode-block" id="Filter.set_integration"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.set_integration">[docs]</a>    def set_integration(self, integration):
        &quot;&quot;&quot;
        Set the filter integration.

        Sets the padding of the FFT filter, the number of frequencies, the
        frequency spacing, and retrieves the channels from the integration if
        necessary.

        Parameters
        ----------
        integration : Integration

        Returns
        -------
        None
        &quot;&quot;&quot;
        self.integration = integration
        self.nt = numba_functions.pow2ceil(integration.size)
        self.nf = self.nt // 2

        dt = self.info.instrument.sampling_interval.decompose().value
        self.df = 1.0 / (dt * self.nt)
        self.set_channels(integration.channels)</div>

<div class="viewcode-block" id="Filter.update_config"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.update_config">[docs]</a>    def update_config(self):
        &quot;&quot;&quot;
        Update the filter based on configuration settings.

        Returns
        -------
        None
        &quot;&quot;&quot;
        if self.integration is None:
            return
        self.enabled = self.integration.has_option(self.get_config_name())
        self.pedantic = self.integration.configuration.get_bool(
            &#39;filter.mrproper&#39;)</div>

<div class="viewcode-block" id="Filter.update_profile"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.update_profile">[docs]</a>    def update_profile(self, channels=None):  # pragma: no cover
        &quot;&quot;&quot;
        Update the profile for given channel(s).

        Parameters
        ----------
        channels : int or numpy.ndarray (int), optional
            The channel indices to update.

        Returns
        -------
        None
        &quot;&quot;&quot;
        pass</div>

<div class="viewcode-block" id="Filter.apply"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.apply">[docs]</a>    def apply(self, report=True):
        &quot;&quot;&quot;
        Apply the filter to the integration.

        There are a few steps that are performed during filter application:

          1. Read the configuration to update any settings.
             - Stop if the filter is not enabled in the configuration.
          2. Pre-filter the channels.  This generally involved removing the
             filter frame and channel dependents form the integration, before
             zeroing them in the filter in order to be re-calculated.
          3. Apply the filter to the channels.
          4. Post-filter the channels.  This generally involves adding the
             filter frame and channel dependents back to the integration.

        Parameters
        ----------
        report : bool, optional
            If `True`, add messages to the integration comments on the
            filtering.

        Returns
        -------
        applied : bool
            `True` if filtering occurred, and `False` otherwise.
        &quot;&quot;&quot;
        self.update_config()

        if not self.is_enabled():
            return False

        self.integration.comments.append(self.get_id())
        self.pre_filter()

        self.frame_parms = np.zeros(self.integration.size, dtype=float)

        self.apply_to_channels(channels=self.get_channels())

        self.parms.add_for_frames(self.frame_parms)

        self.post_filter()

        if report:
            self.report()

        return True</div>

<div class="viewcode-block" id="Filter.apply_to_channels"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.apply_to_channels">[docs]</a>    def apply_to_channels(self, channels=None):
        &quot;&quot;&quot;
        Apply the filter the integration for the channel group.

        Parameters
        ----------
        channels : ChannelGroup, optional
            If not supplied, defaults to the filter channels.

        Returns
        -------
        None
        &quot;&quot;&quot;
        local_temp = self.data is None
        if channels is None:
            channels = self.get_channels()
        if local_temp:
            self.make_temp_data(channels=channels)
        elif channels.size != self.data.shape[0]:
            self.discard_temp_data()
            self.make_temp_data(channels=channels)

        self.load_time_streams(channels=channels)
        self.pre_filter_channels(channels=channels)

        if self.dft:
            self.dft_filter(channels=channels)
        else:
            self.fft_filter(channels=channels)

        if self.pedantic:
            self.level_data_for_channels(channels=channels)

        self.post_filter_channels(channels=channels)

        self.remove(channels=channels)

        if local_temp:
            self.discard_temp_data()</div>

<div class="viewcode-block" id="Filter.pre_filter"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.pre_filter">[docs]</a>    def pre_filter(self):
        &quot;&quot;&quot;
        Perform the pre-filtering steps.

        During the pre-filtering steps, dependents are retrieved from the
        filter integration and cleared (subtracted from integration dependents,
        integration channels, and zeroed).

        Returns
        -------
        None
        &quot;&quot;&quot;
        if self.parms is None:
            self.parms = self.integration.get_dependents(
                self.get_config_name())

        # Sub filters should not directly change the dependents in the
        # integration since this is the job of the parent filter.
        if not self.is_sub_filter:
            self.parms.clear(self.get_channels(),
                             start=0,
                             end=self.integration.size)
        else:
            self.parms.for_frame.fill(0.0)
            self.parms.for_channel.fill(0.0)</div>

<div class="viewcode-block" id="Filter.post_filter"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.post_filter">[docs]</a>    def post_filter(self):
        &quot;&quot;&quot;
        Perform the post-filtering steps.

        During the post-filtering steps, dependents are added to the
        integration and integration channels.

        Returns
        -------
        None
        &quot;&quot;&quot;
        # Sub filters should not directly change the dependents in the
        # integration since this is the job of the parent filter.
        if not self.is_sub_filter:
            self.parms.apply(self.get_channels(),
                             start=0,
                             end=self.integration.size)</div>

<div class="viewcode-block" id="Filter.pre_filter_channels"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.pre_filter_channels">[docs]</a>    def pre_filter_channels(self, channels=None):  # pragma: no cover
        &quot;&quot;&quot;
        Performs the pre-filtering channels steps.

        Parameters
        ----------
        channels : ChannelGroup, optional
            The channel group for which to perform the pre-filtering step.
            If not supplied, defaults to the filtering channels.

        Returns
        -------
        None
        &quot;&quot;&quot;
        pass</div>

<div class="viewcode-block" id="Filter.post_filter_channels"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.post_filter_channels">[docs]</a>    def post_filter_channels(self, channels=None):  # pragma: no cover
        &quot;&quot;&quot;
        Performs the post-filtering channels steps.

        Parameters
        ----------
        channels : ChannelGroup, optional
            The channel group for which to perform the post-filtering step.
            If not supplied, defaults to the filtering channels.

        Returns
        -------
        None
        &quot;&quot;&quot;
        # Remove the DC component...
        # level_data_for(channels)
        pass</div>

<div class="viewcode-block" id="Filter.remove"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.remove">[docs]</a>    def remove(self, channels=None):
        &quot;&quot;&quot;
        Subtract the filtered signal from the integration frame data.

        Parameters
        ----------
        channels : ChannelGroup, optional
            The channel group for which to remove the signal.  If not supplied,
            defaults to the filtering channels.

        Returns
        -------
        None
        &quot;&quot;&quot;
        if channels is None:
            channels = self.get_channels()
        self.remove_from_frames(
            self.data, self.integration.frames, channels)</div>

<div class="viewcode-block" id="Filter.remove_from_frames"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.remove_from_frames">[docs]</a>    @staticmethod
    def remove_from_frames(rejected_signal, frames, channels):
        &quot;&quot;&quot;
        Remove the rejected signal from frame data.

        Parameters
        ----------
        rejected_signal : numpy.ndarray (float)
            The rejected signal of shape (filtering_channels.size, n_frames).
        frames : Frames
            The frames for which to remove the rejected signal.
        channels : ChannelGroup
            The channel for which to subtract the signal.

        Returns
        -------
        None
        &quot;&quot;&quot;
        fnf.remove_rejection_from_frames(
            frame_data=frames.data,
            frame_valid=frames.valid,
            channel_indices=channels.indices,
            rejected_signal=rejected_signal)</div>

<div class="viewcode-block" id="Filter.report"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.report">[docs]</a>    def report(self):
        &quot;&quot;&quot;
        Add messages to the integration comments regarding the filtering.

        Returns
        -------
        None
        &quot;&quot;&quot;
        if self.integration.channels.n_mapping_channels &gt; 0:
            msg = f&#39;({self.get_mean_point_response()})&#39;
        else:
            msg = &#39;(---)&#39;
        self.integration.comments.append(msg)</div>

<div class="viewcode-block" id="Filter.load_time_streams"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.load_time_streams">[docs]</a>    def load_time_streams(self, channels=None):
        &quot;&quot;&quot;
        Load time streams from integration frame data.

        Timestream data is defined as the frame data multiplied by their
        relative weights with the mean subtracted.  Output data are stored
        in the `data` temporary array.  Invalid data are set to zero.  The
        `points` array is also populated and contains the sum of frame weights
        for each channel.  Invalid points are set to zero.

        Parameters
        ----------
        channels : ChannelGroup, optional
            The channels for which to load time streams.  If not supplied,
            defaults to the filtering channels.

        Returns
        -------
        None
        &quot;&quot;&quot;
        if channels is None:
            channels = self.get_channels()

        if self.data is None:
            self.make_temp_data(channels=channels)
        elif self.data.shape[0] != channels.size:
            self.discard_temp_data()
            self.make_temp_data(channels=channels)

        frames = self.integration.frames
        fnf.load_timestream(
            frame_data=frames.data,
            frame_weights=frames.relative_weight,
            frame_valid=frames.valid,
            modeling_frames=frames.is_flagged(&#39;MODELING_FLAGS&#39;),
            channel_indices=channels.indices,
            sample_flags=frames.sample_flag,
            timestream=self.data,
            points=self.points)</div>

<div class="viewcode-block" id="Filter.fft_filter"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.fft_filter">[docs]</a>    def fft_filter(self, channels=None):
        &quot;&quot;&quot;
        Apply the FFT filter to the temporary data.

        Converts data into a rejected (un-levelled) signal

        Parameters
        ----------
        channels : ChannelGroup, optional
            The channels for which to apply the filter.  If not supplied,
            defaults to the stored filtering channels.

        Returns
        -------
        None
        &quot;&quot;&quot;
        freq_channels = np.arange(self.nf + 1)
        rejection = self.rejection_at(freq_channels)
        if not rejection.any():
            return

        if channels is None:
            channels = self.get_channels()

        # Pad with zeros as necessary.
        zero_fill = False
        if self.data.shape[1] &gt; self.integration.size:
            zero_fill = True
            self.data[:, self.integration.size:] = 0.0

        self.data = scipy.fft.rfft(self.data, axis=1)
        self.update_profile(channels=channels)

        self.data[:, 0].real = 0.0
        if rejection.ndim == 1:
            self.data[:, 0].imag *= rejection[self.nf]
            self.data[:, 1:] *= rejection[1:]
        else:
            self.data[:, 0].imag *= rejection[:, self.nf]
            self.data[:, 1:] *= rejection[:, 1:]

        self.data = scipy.fft.irfft(self.data, axis=1)
        if zero_fill:
            self.data[:, self.integration.size:] = 0.0</div>

<div class="viewcode-block" id="Filter.dft_filter"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.dft_filter">[docs]</a>    def dft_filter(self, channels=None):
        &quot;&quot;&quot;
        Return the filter rejection using a discrete FFT.

        The speed of the FFT depends significantly on the number of non-zero
        rejection values.  This will be faster that the `fft_filter` method
        under certain circumstances.

        Parameters
        ----------
        channels : ChannelGroup, optional
            The channel group for which the filtering applied.  By default,
            set to the filtering channels.

        Returns
        -------
        None
        &quot;&quot;&quot;
        freq_channels = np.arange(self.nf + 1)
        rejection = self.rejection_at(freq_channels)
        if not rejection.any():
            return

        fnf.dft_filter_channels(
            frame_data=self.data,
            rejection=rejection,
            n_frames=self.integration.size)</div>

<div class="viewcode-block" id="Filter.calc_point_response"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.calc_point_response">[docs]</a>    def calc_point_response(self):
        &quot;&quot;&quot;
        Returns the point response of a Gaussian source for the filter.

        It is assumed a Gaussian source profile is crossed during the
        integration crossing time such that

        sigma(t) = 1
        t/2.35 * 2pi * sigma(f) = 1
        sigma(f) = 2.35 / (2pi * t)
        df = 1 / (n dt)
        sigma(F) = sigma(f) / df = 2.35 * n * dt / (2pi * t)

        The filter response is not accounted for below the high-pass
        timescale.

        Returns
        -------
        point_response : float
        &quot;&quot;&quot;
        t = self.integration.get_point_crossing_time()
        sigma = gaussian_sigma_to_fwhm / (2 * np.pi * t
                                          * self.df).decompose().value
        a = -0.5 / (sigma ** 2)
        f0 = self.integration.get_modulation_frequency(
            &#39;TOTAL_POWER&#39;).decompose().value / self.df  # Usually the chopper

        # Calculate the x=0 component -- O(N)
        # Below the hi-pass time-scale, the filter has no effect, so count it
        # as such
        min_fi = self.get_high_pass_index()
        frequencies = np.arange(self.nf + 1)
        response = self.response_at(frequencies).copy()
        response[:min_fi] = 1.0

        # Calculate the true source filtering above the hi-pass timescale
        # Consider it a symmetric source profile, peaked at the origin --
        # It&#39;s peak is simply the sum of the cosine terms, which are the real
        # part of the amplitudes.  So, the filter correction is simply the
        # ratio of the sum of the filtered real amplitudes relative to the sum
        # of the original real amplitudes.
        source_response = np.exp(a * ((frequencies - f0) ** 2))
        source_response += np.exp(a * ((frequencies + f0) ** 2))
        return np.sum(source_response * response) / np.sum(source_response)</div>

<div class="viewcode-block" id="Filter.get_high_pass_index"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.get_high_pass_index">[docs]</a>    def get_high_pass_index(self):
        &quot;&quot;&quot;
        Return the high pass filter frequency index.

        Returns
        -------
        index : int
        &quot;&quot;&quot;
        hi_pass_f = (0.5 / self.integration.filter_time_scale).to(
            unit=&#39;Hz&#39;).value
        if np.isnan(hi_pass_f) or hi_pass_f &lt; 0:
            return 1
        return int(np.ceil(hi_pass_f / self.df))</div>

<div class="viewcode-block" id="Filter.level_data_for_channels"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.level_data_for_channels">[docs]</a>    def level_data_for_channels(self, channels=None):
        &quot;&quot;&quot;
        Level (remove average) from the filter data.

        Parameters
        ----------
        channels : ChannelGroup, optional
            The channels for which to average the data, by default

        Returns
        -------
        None
        &quot;&quot;&quot;
        self.level_for_channels(self.data, channels=channels)</div>

<div class="viewcode-block" id="Filter.level_for_channels"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.level_for_channels">[docs]</a>    def level_for_channels(self, signal, channels=None):
        &quot;&quot;&quot;
        Level (remove average) from a given signal.

        Parameters
        ----------
        signal : numpy.ndarray (float)
            The data to level of shape (channels.size, n_frames).
        channels : ChannelGroup, optional
            The channel group for which the data applied.  By default set
            to the filtering channels.

        Returns
        -------
        None
        &quot;&quot;&quot;
        if channels is None or channels is self.channels:
            channel_indices = np.arange(self.channels.size)
        else:
            channel_indices = self.channels.find_fixed_indices(
                channels.fixed_index)

        frames = self.integration.frames
        fnf.level_for_channels(
            signal=signal,
            valid_frame=frames.valid,
            modeling_frame=frames.is_flagged(&#39;MODELING_FLAGS&#39;),
            sample_flag=frames.sample_flag,
            channel_indices=channel_indices)</div>

<div class="viewcode-block" id="Filter.level_data"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.level_data">[docs]</a>    def level_data(self):
        &quot;&quot;&quot;
        Level (remove average from) the filter data.

        Returns
        -------
        None
        &quot;&quot;&quot;
        self.level(self.data)</div>

<div class="viewcode-block" id="Filter.level"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.level">[docs]</a>    def level(self, signal):
        &quot;&quot;&quot;
        Level the given signal data.

        Parameters
        ----------
        signal : numpy.ndarray (float)
            The signal data to level.  Leveling occurs for each channel over
            all frames.  The signal shape should be (n_channels, n_frames) or
            (n_frames,).

        Returns
        -------
        None
        &quot;&quot;&quot;
        if signal.ndim == 1:
            fnf.level_1d(data=signal, n_frames=self.integration.size)
        if signal.ndim == 2:
            fnf.level(data=signal, n_frames=self.integration.size)</div>

<div class="viewcode-block" id="Filter.set_dft"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.set_dft">[docs]</a>    def set_dft(self, value):
        &quot;&quot;&quot;
        Set the DFT flag that determines whether to use FFT or DFT filtering.

        Parameters
        ----------
        value : bool
            If `True`, sets the filtering method to DFT.

        Returns
        -------
        None
        &quot;&quot;&quot;
        self.dft = value</div>

<div class="viewcode-block" id="Filter.get_id"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.get_id">[docs]</a>    @abstractmethod
    def get_id(self):  # pragma: no cover
        &quot;&quot;&quot;
        Return the filter ID.

        Returns
        -------
        filter_id : str
        &quot;&quot;&quot;
        pass</div>

<div class="viewcode-block" id="Filter.get_config_name"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.get_config_name">[docs]</a>    @abstractmethod
    def get_config_name(self):  # pragma: no cover
        &quot;&quot;&quot;
        Return the configuration name.

        Returns
        -------
        config_name : str
        &quot;&quot;&quot;
        pass</div>

<div class="viewcode-block" id="Filter.response_at"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.response_at">[docs]</a>    @abstractmethod
    def response_at(self, fch):  # pragma: no cover
        &quot;&quot;&quot;
        Return the response at a given frequency channel(s).

        Parameters
        ----------
        fch : int or numpy.ndarray (int or bool) or slice
            The frequency channel or channels in question.

        Returns
        -------
        response : float or numpy.ndarray (float)
        &quot;&quot;&quot;
        pass</div>

<div class="viewcode-block" id="Filter.get_mean_point_response"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.filters.filter.Filter.html#sofia_redux.scan.filters.filter.Filter.get_mean_point_response">[docs]</a>    @abstractmethod
    def get_mean_point_response(self):  # pragma: no cover
        &quot;&quot;&quot;
        Return the mean point response of the filter.

        Returns
        -------
        response : float
        &quot;&quot;&quot;
        pass</div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2023, SOFIA-USRA.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 7.1.2. &nbsp;
    Last built 13 Aug 2023. <br/>
  </p>
</footer>
  </body>
</html>