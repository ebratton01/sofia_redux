<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Algorithm &#8212; sofia_redux v1.3.4.dev0</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/bootstrap-sofia.css?v=3fe2c07e" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    
    <script src="../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=602f4d50"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/javascript" src="../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../_static/copybutton.js"></script>
    <link rel="icon" href="../../_static/redux.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Main Classes" href="scan_architecture.html" />
    <link rel="prev" title="sofia_redux.scan: Scan Mode Algorithms for SOFIA Pipelines" href="index.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../index.html"><span id="logotext1">SOFIA</span><span id="logotext2">Redux</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="SOFIA Homepage" href="https://www.sofia.usra.edu/"></a></li>
    <li><a title="General Index" href="../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li class="right">
	<a href="scan_architecture.html" title="Main Classes">
	  next &raquo;
	</a>
      </li>
      <li class="right">
	<a href="index.html" title="sofia_redux.scan: Scan Mode Algorithms for SOFIA Pipelines">
	  &laquo; previous
	</a>
	 |
      </li>
      <li>
	<a href="../../index.html">sofia_redux v1.3.4.dev0</a>
	 &#187;
      </li>
      <li><a href="../index.html" >SOFIA Redux</a> &#187;</li>
      <li><a href="index.html" accesskey="U">sofia_redux.scan: Scan Mode Algorithms for SOFIA Pipelines</a> &#187;</li>
      
      <li>Algorithm</li> 
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="algorithm">
<h1>Algorithm<a class="headerlink" href="#algorithm" title="Permalink to this heading">¶</a></h1>
<p>The mapping algorithm for the output source model implements a nearest-pixel method,
whereby each data point is mapped entirely into the map pixel that falls
nearest to the given detector channel <span class="math notranslate nohighlight">\(c\)</span>, at a given time
<span class="math notranslate nohighlight">\(t\)</span>. Here,</p>
<div class="math notranslate nohighlight">
\[\delta S_{xy} = \frac{\sum\limits_{ct} M_{xy}^{ct} w_c w_t \varkappa_c G_c R_{ct}}{\sum\limits_{ct} M_{xy}^{ct} w_c w_t \varkappa_c^2 G_c^2}\]</div>
<p>where <span class="math notranslate nohighlight">\(M_{xy}^{ct}\)</span> associates each sample <span class="math notranslate nohighlight">\(\{c,t\}\)</span>
uniquely with a map pixel <span class="math notranslate nohighlight">\(\{x,y\}\)</span>, and is effectively the
transpose of the mapping function defined earlier. <span class="math notranslate nohighlight">\(\varkappa_c\)</span>
is the point-source filtering (pass) fraction of the pipeline. It can be
thought of as a single scalar version of the transfer function. Its
purpose is to measure how isolated point-source peaks respond to the
various reduction steps, and correct for it. When done correctly, point
source peaks will always stay perfectly cross-calibrated between
different reductions, regardless of what reduction steps were used in
each case. More generally, a reasonable quality of cross-calibration (to
within 10%) extends to compact and slightly extended sources (typically
up to about half of the field-of-view (FoV) in size). While corrections
for more extended structures (<span class="math notranslate nohighlight">\(\geq\)</span> FoV) are possible to a
certain degree, they come at the price of steeply increasing noise at
the larger scales.</p>
<p>The map-making algorithm should skip over any data that is unsuitable
for quality map-making (such as too-fast scanning that may smear a
source). For formal treatment, we assume that <span class="math notranslate nohighlight">\(M_{ct}^{xy} = 0\)</span>
for any troublesome data.</p>
<p>Calculating the precise dependence of each map point <span class="math notranslate nohighlight">\(S_{xy}\)</span> on
the timestream data <span class="math notranslate nohighlight">\(R_{ct}\)</span> is computationally costly to the
extreme. Instead, the pipeline gets by with the approximation:</p>
<div class="math notranslate nohighlight">
\[p_{ct} \approx N_{xy} \cdot \frac{w_t}{\sum\limits_t w_t} \cdot \frac{w_c \varkappa_c^2 G_c}{\sum\limits_c w_c \varkappa_c^2 G_c^2}\]</div>
<p>This approximation is good as long as most map points are covered with
a representative collection of pixels, and as long as the pixel
sensitivities are more or less uniformly distributed over the field of
view.</p>
<p>We can also calculate the flux uncertainty in the map
<span class="math notranslate nohighlight">\(\sigma_{xy}\)</span> at each point <span class="math notranslate nohighlight">\(\{x,y\}\)</span> as:</p>
<div class="math notranslate nohighlight">
\[\sigma_{xy}^2 = 1 / \sum_{ct} M_{xy}^{ct} w_c w_t \varkappa_c^2 G_c^2\]</div>
<p>Source models are first derived from each input scan separately. These
may be despiked and filtered, if necessary, before added to the global
increment with an appropriate noise weight (based on the observed map
noise) if source weighting is desired.</p>
<p>Once the global increment is complete, we can add it to the prior source
model <span class="math notranslate nohighlight">\(S_{xy}^{r(0)}\)</span> and subject it to further conditioning,
especially in the intermediate iterations. Conditioning operations may
include smoothing, spatial filtering, redundancy flagging, noise or
exposure clipping, signal-to-noise blanking, or explicit source masking.
Once the model is processed into a finalized <span class="math notranslate nohighlight">\(S_{xy}'\)</span>, we
synchronize the incremental change
<span class="math notranslate nohighlight">\(\delta S_{xy}' = S_{xy}' - S_{xy}^{r(0)}\)</span> to the residuals:</p>
<div class="math notranslate nohighlight">
\[R_{ct} \rightarrow R_{ct} - M_{ct}^{xy} (\delta G_c S_{xy}^{r(0)} + G_c \delta S_{xy}')\]</div>
<p>Note, again, that <span class="math notranslate nohighlight">\(\delta S_{xy}' \neq \delta S_{xy}\)</span>. That is,
the incremental change in the conditioned source model is not the same
as the raw increment derived above. Also, since the source gains
<span class="math notranslate nohighlight">\(G_c\)</span> may have changed since the last source model update, we must
also re-synchronize the prior source model <span class="math notranslate nohighlight">\(S_{xy}^{(0)}\)</span> with the
incremental source gain changes <span class="math notranslate nohighlight">\(\delta G_c\)</span> (first term inside
the brackets).</p>
<p>The pipeline operates under the assumption that the point-source
gains <span class="math notranslate nohighlight">\(G_c\)</span> of the detectors are closely related to the observed
sky-noise gains <span class="math notranslate nohighlight">\(g_c\)</span> derived from the correlated noise for all
channels. Specifically, it treats the point-source gains as the
product:</p>
<div class="math notranslate nohighlight">
\[G_c = \varepsilon_c g_c g_s e^{-\tau}\]</div>
<p>where <span class="math notranslate nohighlight">\(\varepsilon_c\)</span> is the point-source coupling efficiency. It
measures the ratio of point-source gains to sky-noise gains (or extended
source gains). Generally, the pipeline will assume <span class="math notranslate nohighlight">\(\varepsilon_c = 1\)</span>,
unless these values are measured and loaded during the initial scan validation
sequence.</p>
<p>Optionally, the pipeline can also derive <span class="math notranslate nohighlight">\(\varepsilon_c\)</span> from
the observed response to a source structure, provided the scan pattern
is sufficient to move significant source flux over all detectors. The
source gains also include a correction for atmospheric attenuation, for
an optical depth <span class="math notranslate nohighlight">\(\tau\)</span>, in-band and in the line of sight.</p>
</section>
<section id="point-source-flux-corrections">
<h1>Point-Source Flux Corrections<a class="headerlink" href="#point-source-flux-corrections" title="Permalink to this heading">¶</a></h1>
<p>We mentioned point-source corrections in the section above; here, we
explain how these are calculated. First, consider drift removal. Its
effect on point source fluxes is a reduction by a factor:</p>
<div class="math notranslate nohighlight">
\[\varkappa_{D,c} \approx 1 - \frac{\tau_{pnt}}{T}\]</div>
<p>In terms of the 1/f drift removal time constant <span class="math notranslate nohighlight">\(T\)</span> and the
typical point-source crossing time <span class="math notranslate nohighlight">\(\tau_{pnt}\)</span>. Clearly, the
effect of 1/f drift removal is smaller the faster one scans across the
source, and becomes negligible when <span class="math notranslate nohighlight">\(\tau_{pnt} \ll T\)</span>.</p>
<p>The effect of correlated-noise removal, over some group of channels of
mode <span class="math notranslate nohighlight">\(i\)</span>, is a little more complex. It is calculated as:</p>
<div class="math notranslate nohighlight">
\[\varkappa_{(i),c} = 1 - \frac{1}{N_{(i),t}} (P_{(i),c} + \sum_k \Omega_{ck} P_{(i),k})\]</div>
<p>where <span class="math notranslate nohighlight">\(\Omega_{ck}\)</span> is the overlap between channels <span class="math notranslate nohighlight">\(c\)</span> and
<span class="math notranslate nohighlight">\(k\)</span>. That is, <span class="math notranslate nohighlight">\(\Omega_{ck}\)</span> is the fraction of the point
source peak measured by channel <span class="math notranslate nohighlight">\(c\)</span> when the source is centered on
channel <span class="math notranslate nohighlight">\(k\)</span>. <span class="math notranslate nohighlight">\(N_{(i),t}\)</span> is the number of correlated
noise-samples that have been derived for the given mode (usually the
same as the number of time samples in the analysis). The correlated
model’s dependence on channel <span class="math notranslate nohighlight">\(c\)</span> is:</p>
<div class="math notranslate nohighlight">
\[P_{(i),c} = \sum_t p_{(i),ct}\]</div>
<p>Finally, the point-source filter correction due to spectral filtering is
calculated based on the average point-source spectrum produced by the
scanning. Gaussian source profiles with spatial spread
<span class="math notranslate nohighlight">\(\sigma_x \approx FWHM / 2.35\)</span> produce a typical temporal spread
<span class="math notranslate nohighlight">\(\sigma_t \approx \sigma_x / \bar{v}\)</span>, in terms of the mean
scanning speed <span class="math notranslate nohighlight">\(\bar{v}\)</span>. In frequency space, this translates to a
Gaussian frequency spread of <span class="math notranslate nohighlight">\(\sigma_f = (2 \pi \sigma_t)^{-1}\)</span>,
and thus a point-source frequency profile of:</p>
<div class="math notranslate nohighlight">
\[\Psi_f \approx e^{-f^2 / (2\sigma_f^2)}\]</div>
<p>More generally, <span class="math notranslate nohighlight">\(\Psi_f\)</span> may be complex-valued (asymmetric beam).
Accordingly, the point-source filter correction due to filtering with
<span class="math notranslate nohighlight">\(\phi_f\)</span> is generally:</p>
<div class="math notranslate nohighlight">
\[\varkappa_{\phi,c} \approx \frac{\sum\limits_f Re(\phi_f \Psi_f \phi_f)}{\sum\limits_f Re(\Psi_f)}\]</div>
<p>The compound point source filtering effect from <span class="math notranslate nohighlight">\(m\)</span> model
components is the product of the individual model corrections, i.e.:</p>
<div class="math notranslate nohighlight">
\[\varkappa_c = \prod_m \varkappa_{(m),c}\]</div>
</section>
<section id="other-resources">
<h1>Other Resources<a class="headerlink" href="#other-resources" title="Permalink to this heading">¶</a></h1>
<p>The scan map reconstruction algorithms are based on a Java pipeline
called CRUSH.  For more information, see:</p>
<ul class="simple">
<li><p>CRUSH paper: <a class="reference external" href="http://adsabs.harvard.edu/abs/2008SPIE.7020E..45K">Kovács, A. 2008, Proc. SPIE, 7020,
45</a></p></li>
<li><p>CRUSH thesis: <a class="reference external" href="http://adsabs.harvard.edu/abs/2006PhDT........28K">Kovács, A. 2006, PhD Thesis,
Caltech</a></p></li>
<li><p>Online documentation: <a class="reference external" href="http://www.sigmyne.com/crush/">http://www.sigmyne.com/crush/</a></p></li>
</ul>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>
<ul>
<li><a class="reference internal" href="#">Algorithm</a></li>
<li><a class="reference internal" href="#point-source-flux-corrections">Point-Source Flux Corrections</a></li>
<li><a class="reference internal" href="#other-resources">Other Resources</a></li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right">
    <a href="../../_sources/sofia_redux/scan/scan_description.rst.txt"
       rel="nofollow">Page Source</a> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2023, SOFIA-USRA.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 7.1.2. &nbsp;
    Last built 13 Aug 2023. <br/>
  </p>
</footer>
  </body>
</html>