==========================
EXES flat processing steps
==========================

Make Flat
=========

Flats are generated by the top level procedure ``makeflat``:
use the card sequence to make a calibrated flat. Also
run ``derive_tort`` on black cards to determine distortion parameters

Steps
-----

#. Calculate mean to find black frame (brightest)

   - ``robustmeancomb``

#.  Determine photon background at given wavelength & temperature, as given
    by the header values WAVENO0 and BB_TEMP respectively.

#.  Calculate the RQE (Robust Quality Estimator?) for the black frame

#.  Determine the sky and shiny frames

#.  Combine all frames grouped by their label (black, shiny, sky, sky2)
    through direct sum

#.  Get flat values by mode

    - Determined by ``cardmode``, initially pulled from header key CARDMODE
      but might be overriden by downstream logic.

    - Available values:
        - BLK
        - NONE
        - SKY
        - SHINY
        - BLKSKY
        - OBJ
        - BLKOBJ
        - BLKSHINY

#. Check for correlation between card frames

#. Check for saturated pixels

#. Clean cards with ``clean``

#. Derive tort parameters with a 2D FFT with ``derive_tort``

#. Clean diff (:math:`diff = black - sky`) frame with ``clean``

#. Calculate flat from

   .. math::

        flat = \frac{B_{\nu}(T_{card})}{black-sky}

#. Calculate variance frame from

    .. math::

        variance = \frac{cardstd^2 * bnut^2}{(black-sky)^4}


#. Update illumination frame with results of flat

    - Correct for tort with ``tortcoord``
    - Mark all out-of-bounds pixels as -1
    - Mark all pixels next to a bad pixel as 0

#. Set the first plane of cards to the second plane

#. Tort the first card with echelon slit skewing  with ``tort``

#. Return flat



Derive Tort
===========

Sets distortion parameters by processing a blackbody flat frame. Identify
orders and illuminated regions. Generates the illumination frame which
indicates which regions of the undistored frame are illuminated.

Steps
-----

1. Undistort input flat data with ``tort``

#. For cross-dispersed data (HIGH-MED or HIGH-LOW) test and optimize distortion

    - Enhance the edges of the image
    - Generate 2D FFT of resulting image
    - Determine order spacing
    - Calculate the angle
    - If :math:`|angle|>0.001` update ``krot`` and rerun distortion correction


#. Generate illumination frame

    .. math::

       power = \sum_y undistorted

       threshold = threshold\_fraction \cdot max(power)

       illum = \left\{
           \begin{array}{c l}
               1 & power > threshold \\
               0 & power < threshold
           \end{array}
           \right\}


#. Update header with the edge definition parameters determined from the
   undistorted flat.

    - NORDERS
    - ODRn\_T1
    - ODRn\_B1
    - ODRn\_XR
    - ORDR_B
    - ORDR_T
    - ORDR_S
    - ORDR_E
    - EDGEDEG: Degree of the polynomial fit to order edges
    - ORDERS: Orders indentified'
    - SLTH\_PIX: Slit height in pixels
    - SLTH\_ARC: Slit height in arcseconds
    - SLTW\_PIX: Slit width in pixels
    - SLTW\_ARC: Slit width in arcseconds
    - RP: Resolving power
    - ROTATION: IDL rotate value



Tort Coord
==========

Calculates undistorted image coordinates. Uses the array size and
tort parameters from the header, along with knowledge of the instrument's
optics, to calculate x- and y-coordinates in the undistorted array that
correspond the x- and y-coordinates of the raw array.


Main Parameters
---------------

HR = High Resolution
XD = Cross-Dispersed

From header
^^^^^^^^^^^
- KROT:
- SLITROT: Slit rotation
- HRG:
- HRR: R number of echelon grating
- XDG:
- XDR: R number of cross-dispering element
- XDDELTA:
- PIXELWD: Pixel width
- XDFL: Adjusted XD focal length
- HRFL: Adjusted echelon focal length
- DETROT: Detector rotation
- BRL:
- X0BRL:
- Y0BRL:
- XORDER1: First pixel of order 1
- SPACING:
- KROT: Rotation angle between chambers


Calculations
^^^^^^^^^^^^
- :math:`hr_{skew}`
- :math:`xk_{skew}`
- :math:`xd_{smile}`
- :math:`xd_{nonlin}`
- :math:`dxd_{skew}`
- :math:`hr_{nonlin}`

Steps
-----

1. Calculate parameters to characterize skew, echelon smile, and
   whatever ``xdnlin`` is.

  - For cross-dispersed modes

    .. math::

      hr_{skew} &= 2 * HRG * HRR * \tan(\theta_{slit})

      xk_{skew}  &=  2 * XDG * XDR * \tan(\theta_{rot})

      xd_{smile}  &=  \frac{-XDR  *  PIXELWD}{XDFL}

      xd_{disp}  &=  \frac{XDFL  *  \left(XDR  -  XDDELTA \right)}{HRFL * HRR}

      xd_{nonlin}  &=  -\left(XDR  +  \frac{1}{2 * XDR}\right)  * \frac{PIXELWD}{2 * XDFL}

      dxd_{skew}  &=  \left(XDG + \frac{xd_{disp}}{2 * XDR}\right)  * \left( 1 + XDR^2 \right)  *  \frac{PIXELWD}{XDFL}

      hr_{nonlin}  &=  -\left( HRR + \frac{1}{2 * HRR}\right)  * \frac{PIXELWD}{2 * HRFL}

      xorder_0  &=  xorder_1  -  \frac{spacing}{2}

  - For longslit modes

    .. math::

       xd_{skew}  &=  2 * XDG * XDR  +  \tan(\theta_{slit})

       xd_{smile}  &=  \frac{-XDR  *  PIXELWD}{XDFL}

       xd_{nonlin}  &=  -\left(XDR + \frac{1}{2 * XDR}\right)  * \frac{PIXELWD}{2 * XDFL}

2. Apply skew, smile, and nonlinearity corrections

  - Generate coordinate arrays with the same shape as a data frame, where
    :math:`x` has values of the distance along the x-axis and :math:`y` has
    values of the distance along the y-axis

  - Distance from each pixel to center

    .. math::

       x_{dist}  =  x  -  \mbox{mean}(x)

       y_{dist}  =  y  -  \mbox{mean}(y)

  - For crossdispersed modes

    - If handling skew

      .. math::

         order  =  \frac{x  -  xorder_0}{spacing}

         y_{dist}  =  y_{dist} + hr_{skew}  *  spacing  *  \left(order - round (order)\right)

    - Correct for nonlinearity of echelon spectrum

      .. math::

         y_{cor}  =  y_{dist}  +  hr_{nonlin}  *  \left( y_{dist}^2  -  y_{mid}^2 \right)

    - Correct for skewing due to cross dispersion, k mirror, and smile

      .. math::

         x_{cor}  =  x_{dist}  +  xd_{disp}*y_{dist}  + xd_{skew}*y_{cor}  +  dxd_{skew}*x_{dist}*y_{cor}  +  xd_{smile}*y_{cor}^2

    - Correct for nonlinearity of xd spectrum

      .. math::

         x_{cor}  =  x_{cor}  +  xd_{nonlin}\left(x_{cor}^2  - x_{mid}^2 \right)

  - For longslit mode, only correct distortions along x-axis

      .. math::

         y_{cor}  =  y_{dist}

         x_{cor}  =  x_{dist}  +  xd_{nonlin} \left(x_{cor}^2  - x_{mid}^2 \right)


3. Apply barrel distortion correction

  .. math::

     barrel  =  1  -  BRL  *  \frac{(x_{cor} - X0BRL)^2  + (y_{cor}-Y0BRL)^2}{x_{mid}^3}

     x_{cor}  =  x_{cor}  *  barrel

     y_{cor}  =  y_{cor}  *  barrel


4. Rotate by detector rotation angle (DETROT).

   .. math::

    u  =  -x_{cor}\cos(DETROT) + y_{cor}\sin(DETROT)  +  x_{mid}

    v  =  -y_{cor}\cos(DETROT) - x_{cor}\sin(DETROT)  +  y_{mid}



Tort
====

Corrects image for optical distortion. Uses ``tortcoord`` to generate
undistorted coordinates from raw pixel coordinates and distortion parameters
in the header. The image is then interpolated onto the undistorted
coordinates. If the variance is provided, it is also interpolated onto
undistorted coordinates.


Main Parameters
---------------


Steps
-----

1. Convert raw coordinates to undistorted coordinates with ``tortcoord``

#. Loop over each frame of the image

#. Interpolate each frame of the image onto new undistorted coordinates

#. Do same for variance

#. Return undistorted image
