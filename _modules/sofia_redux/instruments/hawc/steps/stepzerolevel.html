<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sofia_redux.instruments.hawc.steps.stepzerolevel &#8212; sofia_redux v1.3.4.dev0</title>
    <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/bootstrap-sofia.css?v=3fe2c07e" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/plot_directive.css" />
    
    <script src="../../../../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script data-url_root="../../../../../" id="documentation_options" src="../../../../../_static/documentation_options.js?v=602f4d50"></script>
    <script src="../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script type="text/javascript" src="../../../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../../../_static/copybutton.js"></script>
    <link rel="icon" href="../../../../../_static/redux.ico"/>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../../../index.html"><span id="logotext1">SOFIA</span><span id="logotext2">Redux</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="SOFIA Homepage" href="https://www.sofia.usra.edu/"></a></li>
    <li><a title="General Index" href="../../../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../../../index.html">sofia_redux v1.3.4.dev0</a>
	 &#187;
      </li>
      <li><a href="../../../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sofia_redux.instruments.hawc.steps.stepzerolevel</h1><div class="highlight"><pre>
<span></span># Licensed under a 3-clause BSD style license - see LICENSE.rst
&quot;&quot;&quot;Zero level correction pipeline step.&quot;&quot;&quot;

import re

from astropy import log
from astropy.stats import sigma_clipped_stats
from astropy.wcs import WCS
import numpy as np
from scipy.ndimage import median_filter
from scipy.ndimage.filters import generic_filter

from sofia_redux.instruments.hawc.stepparent import StepParent

__all__ = [&#39;StepZeroLevel&#39;]


<div class="viewcode-block" id="StepZeroLevel"><a class="viewcode-back" href="../../../../../api/sofia_redux.instruments.hawc.steps.stepzerolevel.StepZeroLevel.html#sofia_redux.instruments.hawc.steps.stepzerolevel.StepZeroLevel">[docs]</a>class StepZeroLevel(StepParent):
    &quot;&quot;&quot;
    Correct zero level for scanning data.

    This step applies an optional zero-level correction to the
    Stokes I image for scan mode imaging data, using user input or a
    mean- or median-filter to identify the background region in the
    image.

    Input for this step must be a single DataFits that contains
    3 image planes (HDUs) for the total Stokes I flux.  The three images are:
    DATA, ERROR, and EXPOSURE.

    Output from this step has the same format as the input.
    &quot;&quot;&quot;
<div class="viewcode-block" id="StepZeroLevel.setup"><a class="viewcode-back" href="../../../../../api/sofia_redux.instruments.hawc.steps.stepzerolevel.StepZeroLevel.html#sofia_redux.instruments.hawc.steps.stepzerolevel.StepZeroLevel.setup">[docs]</a>    def setup(self):
        &quot;&quot;&quot;
        Set parameters and metadata for the pipeline step.

        Output files have PRODTYPE = &#39;zerolevel&#39;, and are named with
        the step abbreviation &#39;ZLC&#39;.

        Parameters defined for this step are:

        zero_level_method : {&#39;mean&#39;, &#39;median&#39;, &#39;none&#39;}
            Statistic for zero-level calculation. If &#39;none&#39;, the
            zero-level will not be corrected.  For the other
            options, either a mean or median statistic will be used to
            determine the zero-level value from the region set by the
            region parameters.
        zero_level_region : str
            If set to &#39;header&#39;, the zero-level region will be determined
            from the ZERO_RA, ZERO_DEC, ZERO_RAD keywords
            (for RA center, Dec center, and radius, respectively).
            If set to &#39;auto&#39;, a mean- or median-filter will be
            applied to image, with the radius specified by the
            zero_level_radius parameter.  The lowest negative local
            average is assumed to be the zero level.
            Otherwise, a region may be directly provided as a list of
            [RA center, Dec center, radius], in degrees.
        zero_level_radius : list of float
            Filter radius for zero-level calculation, in arcseconds
            (per band).  Used only for zero_level_region = &#39;auto&#39;.
        zero_level_sigma : float
            Sigma value for statistics clipping.  Ignored for
            zero_level_region = &#39;auto&#39;.
        &quot;&quot;&quot;
        # Name of the pipeline reduction step
        self.name = &#39;zerolevel&#39;
        self.description = &#39;Correct Zero Level&#39;

        # Shortcut for pipeline reduction step and identifier for
        # saved file names.
        self.procname = &#39;zlc&#39;

        # Clear Parameter list
        self.paramlist = []

        # Append parameters
        self.paramlist.append([&#39;zero_level_method&#39;, &#39;none&#39;,
                               &#39;Statistic for zero-level calculation &#39;
                               &#39;(mean, median, none)&#39;])
        self.paramlist.append([&#39;zero_level_region&#39;, &#39;header&#39;,
                               &#39;Zero level region method (header, auto, &#39;
                               &#39;or [RA, Dec, radius] in &#39;
                               &#39;degrees).&#39;])
        self.paramlist.append([&#39;zero_level_radius&#39;,
                               [9.68, 15.6, 15.6, 27.2, 36.4],
                               &#39;Filter radius for zero-level calculation &#39;
                               &#39;in auto mode.&#39;])
        self.paramlist.append([&#39;zero_level_sigma&#39;, 5.0,
                               &#39;Sigma value for statistics clipping in &#39;
                               &#39;non-auto mode.&#39;])</div>

<div class="viewcode-block" id="StepZeroLevel.read_radius"><a class="viewcode-back" href="../../../../../api/sofia_redux.instruments.hawc.steps.stepzerolevel.StepZeroLevel.html#sofia_redux.instruments.hawc.steps.stepzerolevel.StepZeroLevel.read_radius">[docs]</a>    def read_radius(self):
        &quot;&quot;&quot;
        Read a radius value from the parameters.

        The parameters are expected to be defined as a list, with
        one entry for each HAWC band.  The correct value for the
        input data is selected from the list.

        Returns
        -------
        radius : float
            Radius value for the input data.
        &quot;&quot;&quot;
        radius = self.getarg(&#39;zero_level_radius&#39;)
        waveband = self.datain.getheadval(&#39;spectel1&#39;)
        bands = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;]
        try:
            idx = bands.index(waveband[-1])
        except (ValueError, IndexError):
            # waveband not in list
            msg = &#39;Cannot parse waveband: %s&#39; % waveband
            log.error(msg)
            raise ValueError(msg)
        try:
            radius = radius[idx]
        except IndexError:
            msg = &#39;Missing radius values for all wavebands&#39;
            log.error(msg)
            raise IndexError(msg)

        return radius</div>

<div class="viewcode-block" id="StepZeroLevel.correct_zero_level_auto"><a class="viewcode-back" href="../../../../../api/sofia_redux.instruments.hawc.steps.stepzerolevel.StepZeroLevel.html#sofia_redux.instruments.hawc.steps.stepzerolevel.StepZeroLevel.correct_zero_level_auto">[docs]</a>    def correct_zero_level_auto(self, data, method, radius):
        &quot;&quot;&quot;
        Correct image zero level from automatically determined regions.

        Data array is updated in place.

        Parameters
        ----------
        data : array-like
            Data to correct.
        method : {&#39;mean&#39;, &#39;median&#39;}
            Filter method.
        radius : int
            Radius in pixels for filter kernel.
        &quot;&quot;&quot;
        # circular aperture kernel
        kernel = np.zeros((2 * radius + 1, 2 * radius + 1))
        y, x = np.ogrid[-radius:radius + 1, -radius:radius + 1]
        kernel[x ** 2 + y ** 2 &lt;= radius ** 2] = 1

        # mean value and error within aperture at each point,
        # ignoring any regions containing NaNs
        if &#39;mean&#39; in method:
            d_filter = generic_filter(
                data, np.mean, footprint=kernel,
                mode=&#39;constant&#39;, cval=np.nan)
        else:
            # median filter is much faster than generic filter
            # with median function
            d_filter = median_filter(
                data, footprint=kernel,
                mode=&#39;constant&#39;, cval=np.nan)

            # account for NaNs that the median filter ignores
            def func(data):
                return np.any(np.isnan(data))

            d_nan = generic_filter(
                data, func, footprint=kernel,
                mode=&#39;constant&#39;, cval=1)
            d_filter[d_nan &gt; 0] = np.nan

        # check for negative regions
        neg = d_filter &lt; 0
        if np.any(neg):
            # find lowest region
            zero_pix = np.nanargmin(d_filter)
            zero_pix = np.unravel_index(zero_pix, data.shape)
            log.info(f&#39;Correcting zero level &#39;
                     f&#39;at pix x,y: {zero_pix[1]},{zero_pix[0]}&#39;)

            # subtract zero level from filter image at the determined pixel
            zero = d_filter[zero_pix]
            log.info(f&#39;  Zero level: {zero}&#39;)
            data -= zero
        else:
            log.info(&#39;No negative zero level found; not &#39;
                     &#39;subtracting background.&#39;)</div>

<div class="viewcode-block" id="StepZeroLevel.correct_zero_level_region"><a class="viewcode-back" href="../../../../../api/sofia_redux.instruments.hawc.steps.stepzerolevel.StepZeroLevel.html#sofia_redux.instruments.hawc.steps.stepzerolevel.StepZeroLevel.correct_zero_level_region">[docs]</a>    def correct_zero_level_region(self, data, method, region, refheader,
                                  robust=5.0):
        &quot;&quot;&quot;
        Correct image zero level from specified circular regions.

        Data array is updated in place.

        Parameters
        ----------
        data : array-like
            Data to correct.
        method : {&#39;mean&#39;, &#39;median&#39;}
            Statistics method.
        region : list of float
            Region specified as [RA, Dec, radius] in degrees.
        refheader : astropy.Header
            Reference header to use for WCS.
        robust : float
            Sigma value to use for clipping statistics.  Set to 0
            to turn off clipping.

        Raises
        ------
        ValueError
            If any specified region is not on the array.
        &quot;&quot;&quot;
        # reference WCS for identifying background pixels
        ref_wcs = WCS(refheader)

        # coordinates for region check
        ny, nx = data.shape
        y, x = np.ogrid[0:ny, 0:nx]

        # region center and radius
        cx, cy = ref_wcs.wcs_world2pix(region[0], region[1], 0)
        cr = region[2] / np.abs(ref_wcs.wcs.cdelt[0])

        # check that region center is in the array
        if (not np.all(np.isfinite([cx, cy]))
                or (cx &lt; 0 or cx &gt;= nx or cy &lt; 0 or cy &gt;= ny)):
            msg = f&quot;Region {region}, center {cx},{cy} is not &quot; \
                  f&quot;on array with size x,y={nx},{ny}&quot;
            log.error(msg)
            raise ValueError(msg)

        test = ((x - cx) ** 2 + (y - cy) ** 2 &lt;= cr ** 2)
        if robust &gt; 0:
            # sigma clip data before taking stats
            dmed, dmean, dsig = sigma_clipped_stats(data[test], sigma=robust)
            if &#39;mean&#39; in method:
                zero = dmean
            else:
                zero = dmed
        else:
            # just take stats
            if &#39;mean&#39; in method:
                zero = np.nanmean(data[test])
            else:
                zero = np.nanmedian(data[test])

        # now subtract level from image
        log.info(f&#39;Correcting zero level at pix x,y: {cx:.2f},{cy:.2f}&#39;)
        log.info(f&#39;  Zero level: {zero}&#39;)
        data -= zero</div>

<div class="viewcode-block" id="StepZeroLevel.run"><a class="viewcode-back" href="../../../../../api/sofia_redux.instruments.hawc.steps.stepzerolevel.StepZeroLevel.html#sofia_redux.instruments.hawc.steps.stepzerolevel.StepZeroLevel.run">[docs]</a>    def run(self):
        &quot;&quot;&quot;
        Run the data reduction algorithm.

        Because this step is single-in, single-out (SISO),
        self.datain must be a DataFits object. The output
        is also a DataFits object, stored in self.dataout.

        The process is:

        1. Check and gather all input data.
        2. Correct zero level if desired.
        &quot;&quot;&quot;
        # copy input to output
        self.dataout = self.datain.copy()
        header = self.dataout.header
        data = self.dataout.image

        # get zero-level parameters
        zl_method = str(self.getarg(&#39;zero_level_method&#39;)).lower()
        if zl_method not in [&#39;mean&#39;, &#39;median&#39;]:
            log.info(&quot;Method is not &#39;mean&#39; or &#39;median&#39;; &quot;
                     &quot;no zero level correction attempted.&quot;)

        zl_sigma = self.getarg(&#39;zero_level_sigma&#39;)
        zl_radius = self.read_radius()
        zl_region = self.getarg(&#39;zero_level_region&#39;)
        if str(zl_region) not in [&#39;header&#39;, &#39;auto&#39;]:
            try:
                if type(zl_region) is str:
                    region = [re.sub(r&#39;[\&#39;&quot;\[\]]&#39;, &#39;&#39;, v).strip()
                              for v in str(zl_region).split(&#39;,&#39;)]
                else:
                    region = zl_region
                assert len(region) == 3
                region = [float(r) for r in region]
            except (TypeError, ValueError, AssertionError):
                msg = f&#39;Badly formatted zero_level_region: {zl_region}. &#39; \
                      f&#39;Should be [RA, Dec, radius] in degrees.&#39;
                log.error(msg)
                raise ValueError(msg) from None
            zl_region = region

        # check for zero level keywords in the header
        zl_reg_list = None
        if zl_method in [&#39;mean&#39;, &#39;median&#39;]:
            if str(zl_region) == &#39;header&#39;:
                try:
                    zra = header[&#39;ZERO_RA&#39;]
                    zdec = header[&#39;ZERO_DEC&#39;]
                    zrad = header[&#39;ZERO_RAD&#39;]
                    zl_reg_list = [zra, zdec, zrad]
                except KeyError:
                    log.warning(&#39;Missing zero-level region keys &#39;
                                &#39;(ZERO_RA, ZERO_DEC, ZERO_RAD).&#39;)
                    log.warning(&#39;Falling back to auto region method.&#39;)
                    zl_reg_list = None
                else:
                    # catch missing values
                    if np.any(np.isclose(zl_reg_list, -9999)):
                        log.warning(&#39;Missing zero-level region keys &#39;
                                    &#39;(ZERO_RA, ZERO_DEC, ZERO_RAD).&#39;)
                        log.warning(&#39;Falling back to auto region method.&#39;)
                        zl_reg_list = None
            elif isinstance(zl_region, list):
                zl_reg_list = zl_region

        # Correct for zero level from specified region or
        # lowest average value within a specified window
        if zl_method in [&#39;mean&#39;, &#39;median&#39;]:
            do_auto = True
            if zl_reg_list is not None:
                try:
                    self.correct_zero_level_region(data, zl_method,
                                                   zl_reg_list, header,
                                                   robust=zl_sigma)
                except ValueError:
                    log.warning(&#39;Not applying zero level correction &#39;
                                &#39;from specified regions; falling back &#39;
                                &#39;to auto method.&#39;)
                else:
                    do_auto = False
            if do_auto:
                cdelt = np.abs(3600. * header.get(&#39;CDELT1&#39;, 1.0))
                radius = int(np.round(zl_radius / cdelt))
                self.correct_zero_level_auto(data, zl_method, radius)
        else:
            log.debug(&#39;No zero level correction attempted.&#39;)

        # Write out image
        self.dataout.imageset(data)</div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2023, SOFIA-USRA.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 7.1.2. &nbsp;
    Last built 13 Aug 2023. <br/>
  </p>
</footer>
  </body>
</html>