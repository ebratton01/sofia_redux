<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sofia_redux.scan.coordinate_systems.coordinate &#8212; sofia_redux v1.3.4.dev0</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/bootstrap-sofia.css?v=3fe2c07e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    
    <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js?v=602f4d50"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script type="text/javascript" src="../../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../../_static/copybutton.js"></script>
    <link rel="icon" href="../../../../_static/redux.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../../index.html"><span id="logotext1">SOFIA</span><span id="logotext2">Redux</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="SOFIA Homepage" href="https://www.sofia.usra.edu/"></a></li>
    <li><a title="General Index" href="../../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../../index.html">sofia_redux v1.3.4.dev0</a>
	 &#187;
      </li>
      <li><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sofia_redux.scan.coordinate_systems.coordinate</h1><div class="highlight"><pre>
<span></span># Licensed under a 3-clause BSD style license - see LICENSE.rst

from abc import ABC
from astropy import units
from copy import deepcopy
import importlib
import numpy as np

from sofia_redux.scan.coordinate_systems import \
    coordinate_systems_numba_functions as csnf
from sofia_redux.scan.utilities.class_provider import (
    to_module_name, to_class_name)

__all__ = [&#39;Coordinate&#39;]


<div class="viewcode-block" id="Coordinate"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate">[docs]</a>class Coordinate(ABC):

    default_dimensions = 1

    def __init__(self, coordinates=None, unit=None, copy=True):
        &quot;&quot;&quot;
        Initialize a coordinate.

        The Coordinate class is a generic container to store and operate on
        a set of coordinates.

        Parameters
        ----------
        coordinates : list or tuple or array-like or units.Quantity, optional
            The coordinates used to populate the object during initialization.
        unit : str or units.Unit or units.Quantity, optional
            The units of the internal coordinates.
        copy : bool, optional
            If `True`, populate these coordinates with a copy of `coordinates`
            rather than the actual coordinates.
        &quot;&quot;&quot;
        self.coordinates = None
        if unit is None:
            self.unit = None
        else:
            self.unit = units.Unit(unit)
        if coordinates is None:
            return

        coordinates, original = self.check_coordinate_units(coordinates)
        if not original:
            copy = False
        if isinstance(coordinates, Coordinate):
            self.copy_coordinates(coordinates)
        else:
            self.set(coordinates, copy=copy)

<div class="viewcode-block" id="Coordinate.empty_copy"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.empty_copy">[docs]</a>    def empty_copy(self):
        &quot;&quot;&quot;
        Return an unpopulated instance of the coordinates.

        Returns
        -------
        Coordinate
        &quot;&quot;&quot;
        new = self.__class__()
        for attribute, value in self.__dict__.items():
            if attribute not in self.empty_copy_skip_attributes:
                setattr(new, attribute, value)
            else:
                setattr(new, attribute, None)
        return new</div>

<div class="viewcode-block" id="Coordinate.copy"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.copy">[docs]</a>    def copy(self):
        &quot;&quot;&quot;
        Return a copy of the Coordinate.

        Returns
        -------
        Coordinate
        &quot;&quot;&quot;
        return deepcopy(self)</div>

    @property
    def empty_copy_skip_attributes(self):
        &quot;&quot;&quot;
        Return attributes that are set to None on an empty copy.

        Returns
        -------
        attributes : set (str)
        &quot;&quot;&quot;
        return {&#39;coordinates&#39;}

    @property
    def ndim(self):
        &quot;&quot;&quot;
        Return the number of dimensions for the coordinate.

        Returns
        -------
        int
        &quot;&quot;&quot;
        if self.coordinates is None:
            return 0
        elif not isinstance(self.coordinates, np.ndarray):
            return 1
        elif self.coordinates.ndim == 1:
            return 1
        else:
            return self.coordinates.shape[0]

    @property
    def shape(self):
        &quot;&quot;&quot;
        Return the shape of the coordinates.

        Returns
        -------
        tuple (int)
        &quot;&quot;&quot;
        if self.coordinates is None or self.singular:
            return ()
        return self.coordinates.shape[1:]

    @shape.setter
    def shape(self, new_shape):
        &quot;&quot;&quot;
        Set a new shape for the coordinates

        Parameters
        ----------
        new_shape : int or tuple (int)

        Returns
        -------
        None
        &quot;&quot;&quot;
        self.set_shape(new_shape)

    @property
    def size(self):
        &quot;&quot;&quot;
        Return the number of coordinates.

        Returns
        -------
        int
        &quot;&quot;&quot;
        if self.coordinates is None:
            return 0
        elif self.singular:
            return 1
        else:
            return int(np.prod(self.coordinates.shape[1:]))

    @property
    def singular(self):
        &quot;&quot;&quot;
        Return if the coordinates are scalar in nature (not an array).

        Returns
        -------
        bool
        &quot;&quot;&quot;
        if self.coordinates is None:
            return True
        if self.coordinates.ndim == 1:
            return self.coordinates.size == 1
        if self.coordinates.ndim &gt; 1:
            return np.prod(self.coordinates.shape[1:]) &lt;= 1
        return True  # pragma: no cover

    @property
    def length(self):
        &quot;&quot;&quot;
        Return the Euclidean distance of the coordinates from (0, 0).

        Returns
        -------
        distance : float or numpy.ndarray or astropy.units.Quantity
        &quot;&quot;&quot;
        if self.ndim == 0:
            return np.nan if self.unit is None else np.nan * self.unit
        elif self.ndim == 1:
            return np.abs(self.coordinates)
        else:
            return np.linalg.norm(self.coordinates, axis=0)

    def __eq__(self, other):
        &quot;&quot;&quot;
        Test if these coordinates are equal to another.

        Parameters
        ----------
        other : Coordinate

        Returns
        -------
        bool
        &quot;&quot;&quot;
        if other is self:
            return True
        if self.__class__ != other.__class__:
            return False

        if self.coordinates is None:
            return other.coordinates is None
        elif other.coordinates is None:
            return self.coordinates is None

        if self.shape != other.shape:
            return False

        try:
            return np.allclose(self.coordinates, other.coordinates,
                               equal_nan=True)
        except units.UnitConversionError:
            return False

    def __len__(self):
        &quot;&quot;&quot;
        Return the number of stored coordinates.

        Returns
        -------
        int
        &quot;&quot;&quot;
        return self.size

    def __getitem__(self, indices):
        &quot;&quot;&quot;
        Return a section of the coordinates

        Parameters
        ----------
        indices : int or numpy.ndarray or slice

        Returns
        -------
        Coordinate
        &quot;&quot;&quot;
        return self.get_indices(indices)

    def __setitem__(self, indices, value):
        &quot;&quot;&quot;
        Set the coordinates for given indices.

        Parameters
        ----------
        indices : slice or int or numpy.ndarray (int or bool)
        value : Coordinate

        Returns
        -------
        None
        &quot;&quot;&quot;
        self.paste(value, indices)

<div class="viewcode-block" id="Coordinate.get_indices"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.get_indices">[docs]</a>    def get_indices(self, indices):
        &quot;&quot;&quot;
        Return selected data for given indices.

        Parameters
        ----------
        indices : slice or list or int or numpy.ndarray (int)
            The indices to extract.

        Returns
        -------
        Coordinate
        &quot;&quot;&quot;
        new = self.empty_copy()
        if self.coordinates is None:
            return new

        if self.singular:
            raise KeyError(&quot;Cannot retrieve indices for singular coordinates.&quot;)

        if isinstance(indices, np.ndarray) and indices.shape == ():
            indices = int(indices)

        all_indices = slice(None),  # dimensions
        if not isinstance(indices, tuple):
            all_indices += indices,
        else:
            all_indices += indices

        coordinates = self.coordinates[all_indices]
        if new.ndim == 0 and self.ndim &gt; 0 and coordinates.ndim &lt;= 1:
            # For the case of base coordinates and multi-dimensional
            coordinates = coordinates[..., None]

        new.coordinates = coordinates
        return new</div>

<div class="viewcode-block" id="Coordinate.set_shape"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.set_shape">[docs]</a>    def set_shape(self, shape, empty=False):
        &quot;&quot;&quot;
        Set the shape of the coordinates.

        If the current coordinates are blank, dimensionality will be inferred
        from the input shape.  If a single integer value or 1-tuple is passed
        in, the number of dimensions will be set to 1.  Otherwise, the
        dimensionality will be permanently set to the first element of `shape`.

        Parameters
        ----------
        shape : int or tuple (int)
        empty : bool, optional
            If `True`, create an empty array.  Otherwise, create a zeroed
            array.

        Returns
        -------
        None
        &quot;&quot;&quot;
        if isinstance(shape, int):
            shape = shape,

        shape_dim = len(shape)

        if self.ndim == 0:
            # Dimensionality is inferred from this shape if not set.
            if shape_dim == 1:
                new_shape = (1,) + shape
            else:
                new_shape = shape
        else:
            new_shape = (self.ndim,) + shape

        if empty:
            self.coordinates = np.empty(new_shape, dtype=float)
        else:
            self.coordinates = np.zeros(new_shape, dtype=float)

        if self.unit is not None:
            self.coordinates = self.coordinates * self.unit</div>

<div class="viewcode-block" id="Coordinate.set_singular"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.set_singular">[docs]</a>    def set_singular(self, empty=False):
        &quot;&quot;&quot;
        Create a single coordinate.

        Parameters
        ----------
        empty : bool, optional
            If `True`, create an empty coordinate array.  Otherwise, create a
            zeroed array.

        Returns
        -------
        None
        &quot;&quot;&quot;
        if self.ndim &lt;= 1:
            shape = (1,)
        else:
            shape = (self.ndim, 1)

        if empty:
            coordinates = np.empty(shape, dtype=float)
        else:
            coordinates = np.zeros(shape, dtype=float)

        if self.unit is not None:
            coordinates = coordinates * self.unit
        self.coordinates = coordinates</div>

<div class="viewcode-block" id="Coordinate.set_shape_from_coordinates"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.set_shape_from_coordinates">[docs]</a>    def set_shape_from_coordinates(self, coordinates, single_dimension=False,
                                   empty=False, change_unit=True):
        &quot;&quot;&quot;
        Set the new shape and units from the given coordinates.

        The dimensionality of this coordinate will be determined from the input
        `coordinates` if not previously defined.  Otherwise, any previously
        determined dimensionality will remain fixed and cannot be altered.

        Parameters
        ----------
        coordinates : numpy.ndarray (float) or astropy.units.Quantity
        single_dimension : bool, optional
            If `True`, the coordinates consist of data from only one of the
            dimensions.  Note that this is only applicable if the current
            dimensionality has been determined.  If `False`, the shape of the
            coordinates will be determined from `coordinates[0]`.  In the case
            where coordinates.ndim &lt;= 1, the new shape will be set to a
            singular value.
        empty : bool, optional
            If `True` and a new array should be created, that array will be
            empty.  Otherwise, a zero array will be created.
        change_unit : bool, optional
            If `True`, allow the unit to be updated.

        Returns
        -------
        None
        &quot;&quot;&quot;
        if isinstance(coordinates, units.Quantity):
            new_unit = coordinates.unit
        else:
            new_unit = None

        coordinates = np.asarray(coordinates)

        if single_dimension or self.ndim == 0:
            if coordinates.shape == ():
                singular = True
                shape = ()
            else:
                singular = False
                shape = coordinates.shape
        else:
            if coordinates.ndim &lt;= 1:
                singular = True
                shape = ()
            else:
                singular = False
                shape = coordinates[0].shape

        if change_unit and self.unit is None and new_unit is not None:
            self.unit = new_unit

        if singular:
            if not self.singular or self.coordinates is None:
                self.set_singular(empty=empty)
        else:
            if self.shape != shape or self.coordinates is None:
                self.set_shape(shape, empty=empty)</div>

<div class="viewcode-block" id="Coordinate.check_coordinate_units"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.check_coordinate_units">[docs]</a>    def check_coordinate_units(self, coordinates):
        &quot;&quot;&quot;
        Check the coordinate units and update parameters if necessary.

        This method takes in a set of coordinates and returns a more
        standardized version consistent with these coordinates.  Coordinate
        units will be converted to these coordinates, or if no units exist for
        these coordinates, they will be inferred from the input `coordinates`.

        If the given coordinates are a Coordinate subclass, they will be
        converted to the current units, and any other array like input will
        be converted to an numpy array or units.Quantity depending on whether
        units for these coordinates have been defined (or inferred from
        `coordinates`).

        Parameters
        ----------
        coordinates : list or tuple or numpy.ndarray or units.Quantity or None
            The coordinates to check.

        Returns
        -------
        coordinates, original : numpy.ndarray or units.Quantity or Coordinate
            Returns the coordinates in the same unit as the coordinates, and
            whether the coordinates are the original coordinates.
        &quot;&quot;&quot;
        if coordinates is None:
            return None, True

        original = True
        coordinate_unit = None
        if isinstance(coordinates, (Coordinate, units.Quantity)):
            coordinate_unit = coordinates.unit

        else:  # In the case that coordinates have been supplied weirdly
            if isinstance(coordinates, np.ndarray):
                n = 0 if coordinates.shape == () else coordinates.shape[0]
            elif hasattr(coordinates, &#39;__len__&#39;):
                n = len(coordinates)
            else:
                n = 0

            if n &gt; 0:
                if isinstance(coordinates[0], units.Quantity):
                    coordinate_unit = coordinates[0].unit
                    if coordinates[0].shape != ():
                        shape = (len(coordinates),) + coordinates[0].shape
                    else:
                        shape = len(coordinates),
                    new = np.empty(shape, dtype=float) * coordinate_unit
                    for dimension in range(shape[0]):
                        new[dimension] = coordinates[dimension]
                    coordinates = new
                    original = False
                elif not isinstance(coordinates, np.ndarray):
                    coordinates = np.asarray(coordinates)
                    original = False

        # Convert string values to floats
        if isinstance(coordinates, np.ndarray):
            if coordinates.dtype.kind in [&#39;S&#39;, &#39;U&#39;]:
                coordinates = coordinates.astype(float)

        if coordinate_unit == units.dimensionless_unscaled:
            coordinate_unit = None
            if isinstance(coordinates, Coordinate):
                coordinates = coordinates.copy()
                original = False
                coordinates.unit = None
                coordinates.coordinates = coordinates.coordinates.value
            elif isinstance(coordinates, units.Quantity):
                coordinates = coordinates.value  # Still references data

        if self.unit is None and coordinate_unit is not None:
            self.unit = coordinate_unit

        if self.unit is not None:
            if coordinate_unit is None:
                if isinstance(coordinates, Coordinate):
                    coordinates = coordinates.copy()
                    coordinates.coordinates = (
                        coordinates.coordinates * self.unit)
                    coordinates.unit = self.unit
                else:
                    coordinates = coordinates * self.unit
                original = False
            elif coordinate_unit != self.unit:
                if isinstance(coordinates, Coordinate):
                    coordinates = coordinates.copy()
                    coordinates.change_unit(self.unit)
                elif isinstance(coordinates, units.Quantity):
                    coordinates = coordinates.to(self.unit)
                original = False

        return coordinates, original</div>

<div class="viewcode-block" id="Coordinate.change_unit"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.change_unit">[docs]</a>    def change_unit(self, unit):
        &quot;&quot;&quot;
        Change the coordinate units.

        Parameters
        ----------
        unit : str or units.Unit

        Returns
        -------
        None
        &quot;&quot;&quot;
        unit = units.Unit(unit)
        if unit == self.unit:
            return
        self.unit = unit

        if self.coordinates is None:
            return
        if isinstance(self.coordinates, units.Quantity):
            self.coordinates = self.coordinates.to(unit)
        elif isinstance(self.coordinates, (np.ndarray, int, float)):
            self.coordinates = self.coordinates * unit</div>

<div class="viewcode-block" id="Coordinate.broadcast_to"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.broadcast_to">[docs]</a>    def broadcast_to(self, thing):
        &quot;&quot;&quot;
        Broadcast to a new shape if possible.

        If the coordinates are singular (a single coordinate value in each
        dimension), broadcasts that single value to a new shape in the internal
        coordinates.

        Parameters
        ----------
        thing : numpy.ndarray or tuple (int)
            An array from which to determine the broadcast shape, or a tuple
            containing the broadcast shape.

        Returns
        -------
        None
        &quot;&quot;&quot;
        if not self.singular:
            return
        if isinstance(thing, np.ndarray):
            shape = thing.shape
        elif isinstance(thing, tuple):
            shape = thing
        else:
            return

        if shape == ():
            return
        singular_coordinates = self.coordinates
        n_dimensions = self.ndim
        real_shape = (self.ndim,) + shape
        self.coordinates = np.empty_like(self.coordinates, shape=real_shape)
        for dimension in range(n_dimensions):
            self.coordinates[dimension] = singular_coordinates[dimension]</div>

<div class="viewcode-block" id="Coordinate.add"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.add">[docs]</a>    def add(self, coordinates):
        &quot;&quot;&quot;
        Add other coordinates to these.

        Parameters
        ----------
        coordinates : Coordinate

        Returns
        -------
        None
        &quot;&quot;&quot;
        self.broadcast_to(coordinates.shape)
        self.coordinates += coordinates.coordinates</div>

<div class="viewcode-block" id="Coordinate.subtract"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.subtract">[docs]</a>    def subtract(self, coordinates):
        &quot;&quot;&quot;
        Subtract other coordinates from these.

        Parameters
        ----------
        coordinates : Coordinate

        Returns
        -------
        None
        &quot;&quot;&quot;
        self.broadcast_to(coordinates.shape)
        self.coordinates -= coordinates.coordinates</div>

<div class="viewcode-block" id="Coordinate.scale"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.scale">[docs]</a>    def scale(self, factor):
        &quot;&quot;&quot;
        Scale the coordinates by a factor.

        Parameters
        ----------
        factor : int or float or Coordinate or iterable or np.ndarray
            If a Coordinate is supplied, it must be singular.

        Returns
        -------
        None
        &quot;&quot;&quot;
        if isinstance(factor, Coordinate):
            self.broadcast_to(factor.shape)
            self.coordinates *= factor.coordinates

        else:
            if not hasattr(factor, &#39;__len__&#39;):
                factor = self.convert_factor(factor)
                self.coordinates *= factor
                return

            factor, _ = self.check_coordinate_units(factor)
            factor = self.convert_factor(factor)
            if factor.size &lt; 1:
                return
            if factor.size == 1:
                self.coordinates *= np.atleast_1d(factor.ravel())[0]
            elif factor.ndim &lt;= 1 and factor.size == self.ndim:
                for i in range(factor.size):
                    self.coordinates[i] *= factor[i]
            else:
                self.broadcast_to(factor.shape[1:])
                self.coordinates *= factor</div>

<div class="viewcode-block" id="Coordinate.convert_factor"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.convert_factor">[docs]</a>    def convert_factor(self, factor):
        &quot;&quot;&quot;
        Returns a float factor in the correct units for multiplication.

        If the current coordinates are not quantities, they will be converted
        to such if the factor is a quantity.  Otherwise, the factor scaled to
        units of the coordinates will be returned.

        Parameters
        ----------
        factor : float or numpy.ndarray or units.Quantity

        Returns
        -------
        factor : float or numpy.ndarray (float)
        &quot;&quot;&quot;
        if not isinstance(factor, units.Quantity):
            return factor

        if factor.unit == units.dimensionless_unscaled:
            return factor.value

        if self.unit is None or self.unit == units.dimensionless_unscaled:
            self.unit = factor.unit
            if self.coordinates is not None:  # Change coordinates
                self.coordinates = self.coordinates * factor.unit

            factor_value = factor.value
        else:
            factor_value = factor.to(self.unit).value

        return factor_value</div>

<div class="viewcode-block" id="Coordinate.fill"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.fill">[docs]</a>    def fill(self, value, indices=None):
        &quot;&quot;&quot;
        Fill the coordinates with the given value.

        Parameters
        ----------
        value : int or float or units.Quantity
            The value with which to fill the coordinates.
        indices : slice or numpy.ndarray (int or bool), optional
            The indices to set to NaN.

        Returns
        -------
        None
        &quot;&quot;&quot;
        if self.size == 0:
            return

        if (isinstance(value, units.Quantity)
                and value.unit == units.dimensionless_unscaled):
            value = value.value

        if not isinstance(value, units.Quantity):
            if self.unit is not None:
                value = value * self.unit
        elif self.unit is None:
            self.change_unit(value.unit)

        if (not isinstance(self.coordinates, np.ndarray)
                or self.coordinates.shape == ()):
            if isinstance(value, units.Quantity):
                value = value.to(self.unit)
            self.coordinates = value
            return

        if indices is None or self.singular:
            self.coordinates.fill(value)
        elif self.ndim == 1 and self.coordinates.ndim == 1:
            self.coordinates[indices] = value
        else:
            self.coordinates[:, indices] = value</div>

<div class="viewcode-block" id="Coordinate.nan"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.nan">[docs]</a>    def nan(self, indices=None):
        &quot;&quot;&quot;
        Set all coordinates to NaN.

        Parameters
        ----------
        indices : slice or numpy.ndarray (int or bool), optional
            The indices to set to NaN.

        Returns
        -------
        None
        &quot;&quot;&quot;
        if self.coordinates is None:
            return

        if (not isinstance(self.coordinates, np.ndarray)
                or self.coordinates.shape == ()):
            if self.unit is not None:
                self.coordinates = np.nan * self.unit
            else:
                self.coordinates = np.nan
            return

        if indices is None:
            self.coordinates.fill(np.nan)
        elif self.coordinates.ndim == 1:
            self.coordinates[indices] = np.nan
        else:
            self.coordinates[:, indices] = np.nan</div>

<div class="viewcode-block" id="Coordinate.zero"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.zero">[docs]</a>    def zero(self, indices=None):
        &quot;&quot;&quot;
        Set all coordinates to zero.

        Parameters
        ----------
        indices : slice or numpy.ndarray (int or bool), optional
            The indices to set to zero.

        Returns
        -------
        None
        &quot;&quot;&quot;
        if self.coordinates is None:
            return

        if (not isinstance(self.coordinates, np.ndarray)
                or self.coordinates.shape == ()):
            if self.unit is not None:
                self.coordinates = 0.0 * self.unit
            else:
                self.coordinates = 0.0
            return

        if indices is None:
            self.coordinates.fill(0.0)
        elif self.coordinates.ndim == 1:
            self.coordinates[indices] = 0.0
        else:
            self.coordinates[:, indices] = 0.0</div>

<div class="viewcode-block" id="Coordinate.apply_coordinate_mask_function"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.apply_coordinate_mask_function">[docs]</a>    @staticmethod
    def apply_coordinate_mask_function(coordinates, func):
        &quot;&quot;&quot;
        Apply a masking function to a given set of coordinates.

        Parameters
        ----------
        coordinates : units.Quantity or numpy.ndarray
            The coordinates to check.  Must consist of an array with 2 or
            more dimensions.  I.e., of shape (ndim, x1, x2, ...).
        func : function
            A function that returns a boolean mask given a numpy array.  For
            these purposes, it should take in a two dimensional array of shape
            (ndim, n) where n = product(x1, x2, ...).

        Returns
        -------
        mask : numpy.ndarray (bool)
            The boolean mask output by `func` of shape (x1, x2, ...).
        &quot;&quot;&quot;
        if isinstance(coordinates, units.Quantity):
            data = coordinates.value
        else:
            data = coordinates

        if data.ndim &gt; 2:
            shape = data.shape
            shape2d = shape[0], int(np.prod(shape[1:]))
            mask = func(data.reshape(shape2d)).reshape(shape[1:])
        else:
            mask = func(data)
        return mask</div>

<div class="viewcode-block" id="Coordinate.is_null"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.is_null">[docs]</a>    def is_null(self):
        &quot;&quot;&quot;
        Check whether coordinates are zero.

        Returns
        -------
        bool or numpy.ndarray (bool)
        &quot;&quot;&quot;
        if self.coordinates is None:
            return False
        elif self.singular:
            return np.all(self.coordinates == 0)
        elif self.coordinates.ndim == 1:
            return self.coordinates == 0
        else:
            return self.apply_coordinate_mask_function(
                self.coordinates, csnf.check_null)</div>

<div class="viewcode-block" id="Coordinate.is_nan"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.is_nan">[docs]</a>    def is_nan(self):
        &quot;&quot;&quot;
        Check whether coordinates are NaN.

        Returns
        -------
        bool or numpy.ndarray (bool)
        &quot;&quot;&quot;
        if self.coordinates is None:
            return False
        elif self.singular:
            return np.all(np.isnan(self.coordinates))
        elif self.coordinates.ndim == 1:
            return np.isnan(self.coordinates)
        else:
            return self.apply_coordinate_mask_function(
                self.coordinates, csnf.check_nan)</div>

<div class="viewcode-block" id="Coordinate.is_finite"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.is_finite">[docs]</a>    def is_finite(self):
        &quot;&quot;&quot;
        Check whether coordinates are finite.

        Returns
        -------
        bool or numpy.ndarray (bool)
        &quot;&quot;&quot;
        if self.coordinates is None:
            return False
        elif self.singular:
            return np.all(np.isfinite(self.coordinates))
        elif self.coordinates.ndim == 1:
            return np.isfinite(self.coordinates)
        else:
            return self.apply_coordinate_mask_function(
                self.coordinates, csnf.check_finite)</div>

<div class="viewcode-block" id="Coordinate.is_infinite"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.is_infinite">[docs]</a>    def is_infinite(self):
        &quot;&quot;&quot;
        Check whether coordinates are infinite.

        Returns
        -------
        bool or numpy.ndarray (bool)
        &quot;&quot;&quot;
        if self.coordinates is None:
            return False
        elif self.singular:
            return np.all(np.isinf(self.coordinates))
        elif self.coordinates.ndim == 1:
            return np.isinf(self.coordinates)
        else:
            return self.apply_coordinate_mask_function(
                self.coordinates, csnf.check_infinite)</div>

<div class="viewcode-block" id="Coordinate.convert_from"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.convert_from">[docs]</a>    def convert_from(self, coordinates):
        &quot;&quot;&quot;
        Convert coordinates from another or same system to this.

        Parameters
        ----------
        coordinates : Coordinate

        Returns
        -------
        None
        &quot;&quot;&quot;
        self.copy_coordinates(coordinates)</div>

<div class="viewcode-block" id="Coordinate.convert_to"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.convert_to">[docs]</a>    def convert_to(self, coordinates):
        &quot;&quot;&quot;
        Convert these coordinates to another coordinate system.

        Parameters
        ----------
        coordinates : Coordinate

        Returns
        -------
        None
        &quot;&quot;&quot;
        coordinates.convert_from(self)</div>

<div class="viewcode-block" id="Coordinate.correct_factor_dimensions"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.correct_factor_dimensions">[docs]</a>    @staticmethod
    def correct_factor_dimensions(factor, array):
        &quot;&quot;&quot;
        Corrects the factor dimensionality prior to an array +-/* etc.

        Frame operations are frequently of the form result = factor op array
        where factor is of shape (n_frames,) and array is of shape
        (n_frames, ...).  This procedure updates the factor shape so that
        array operations are possible.  E.g., if factor is of shape (5,) and
        array is of shape (5, 10), then the output factor will be of shape
        (5, 1) and allow the two arrays to operate with each other.

        Parameters
        ----------
        factor : int or float or numpy.ndarray or astropy.units.Quantity
            The factor to check.
        array : numpy.ndarray or astropy.units.Quantity or Coordinate
            The array to check against

        Returns
        -------
        working_factor : numpy.ndarray or astropy.units.Quantity
        &quot;&quot;&quot;
        if not isinstance(factor, np.ndarray):
            return factor
        if factor.shape == ():
            return factor

        if isinstance(array, Coordinate):
            array_ndim = len(array.shape)
        else:
            array_ndim = array.ndim

        add_dimensions = array_ndim - factor.ndim
        if add_dimensions == 0:
            return factor
        elif add_dimensions &gt; 0:
            for i in range(add_dimensions):
                factor = factor[..., None]

        return factor</div>

<div class="viewcode-block" id="Coordinate.get_class"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.get_class">[docs]</a>    @classmethod
    def get_class(cls, class_name=None):
        &quot;&quot;&quot;
        Return a coordinate class for a given name.

        Parameters
        ----------
        class_name : str, optional
            The name of the class not including the &quot;Coordinates&quot; suffix.  The
            default is *this* class.

        Returns
        -------
        coordinate_class : class``
        &quot;&quot;&quot;
        if class_name is None:
            return cls

        base_module_name = &#39;.&#39;.join(Coordinate.__module__.split(&#39;.&#39;)[:-1])

        # Determine if it&#39;s a class from whether the class name is mixed case
        is_class = not (class_name.isupper() or class_name.islower())
        user_class_name = class_name
        if is_class:
            module_name = to_module_name(class_name)
        else:
            module_name = class_name.lower()

        if module_name.endswith(&#39;_d&#39;):
            module_name = module_name[:-2] + &#39;d&#39;

        possibilities = [&#39;%s&#39;, &#39;coordinate_%s&#39;, &#39;%s_coordinates&#39;]
        for possibility in possibilities:
            module_basename = possibility % module_name
            try_module = f&#39;{base_module_name}.{module_basename}&#39;
            try:
                module = importlib.import_module(try_module)
                class_name = to_class_name(module_basename)
                if class_name[-1] == &#39;d&#39; and class_name[-2].isdigit():
                    class_name = class_name[:-1] + class_name[-1].upper()
                break
            except ModuleNotFoundError:
                pass
        else:
            module = class_name = None

        if module is None:
            raise ValueError(f&quot;Could not find {user_class_name} class module.&quot;)

        coordinate_class = getattr(module, class_name)
        if coordinate_class is None:  # pragma: no cover
            # If this gets hit it&#39;s because modules/classes weren&#39;t named well.
            raise ValueError(f&quot;Could not find {class_name} in {module} given &quot;
                             f&quot;user input {user_class_name}.&quot;)

        if not issubclass(coordinate_class, Coordinate):
            raise ValueError(f&quot;Retrieved class {coordinate_class} is not a &quot;
                             f&quot;{Coordinate} sub class.&quot;)

        return coordinate_class</div>

<div class="viewcode-block" id="Coordinate.get_instance"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.get_instance">[docs]</a>    @classmethod
    def get_instance(cls, class_name=None):
        &quot;&quot;&quot;
        Return a coordinate instance for a given name.

        Parameters
        ----------
        class_name : str, optional
            The name of the class not including the &quot;Coordinates&quot; suffix.  The
            default is *this* class.

        Returns
        -------
        object : Coordinate2D or SphericalCoordinates or CelestialCoordinates
        &quot;&quot;&quot;
        return cls.get_class(class_name=class_name)()</div>

<div class="viewcode-block" id="Coordinate.insert_blanks"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.insert_blanks">[docs]</a>    def insert_blanks(self, insert_indices):
        &quot;&quot;&quot;
        Insert blank (NaN) values at the requested indices.

        Follows the logic of :func:`numpy.insert`.

        Parameters
        ----------
        insert_indices : numpy.ndarray (int)

        Returns
        -------
        None
        &quot;&quot;&quot;
        if self.coordinates is None or self.singular:
            return

        if self.coordinates.ndim == 1:
            self.coordinates = np.insert(self.coordinates, insert_indices,
                                         np.nan)
        else:
            self.coordinates = np.insert(
                self.coordinates, insert_indices, np.nan, axis=1)</div>

<div class="viewcode-block" id="Coordinate.merge"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.merge">[docs]</a>    def merge(self, other):
        &quot;&quot;&quot;
        Append other coordinates to the end of these.

        Parameters
        ----------
        other : Coordinate

        Returns
        -------
        None
        &quot;&quot;&quot;
        if other.coordinates is None:
            return

        if self.coordinates is None:
            self.copy_coordinates(other)
            return

        if other.ndim != self.ndim:
            raise ValueError(&quot;Coordinate dimensions do not match.&quot;)

        coordinates = self.coordinates
        if self.ndim == 1 and coordinates.ndim == 1:
            coordinates = coordinates[None]
        elif self.ndim &gt; 1 and coordinates.ndim == 1:
            coordinates = coordinates[:, None]

        other_c = other.coordinates
        if other.ndim == 1 and other_c.ndim == 1:
            other_c = other_c[None]
        elif other.ndim &gt; 1 and other_c.ndim == 1:
            other_c = other_c[:, None]

        self.coordinates = np.concatenate((coordinates, other_c), axis=1)</div>

<div class="viewcode-block" id="Coordinate.paste"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.paste">[docs]</a>    def paste(self, coordinates, indices):
        &quot;&quot;&quot;
        Paste new coordinate values at the given indices.

        Parameters
        ----------
        coordinates : Coordinate
        indices : numpy.ndarray (int)

        Returns
        -------
        None
        &quot;&quot;&quot;
        if self.singular or self.coordinates is None:
            raise ValueError(&quot;Cannot paste onto singular &quot;
                             &quot;or empty coordinates.&quot;)
        elif coordinates.coordinates is None:
            raise ValueError(&quot;Cannot paste empty coordinates.&quot;)
        elif self.ndim != coordinates.ndim:
            raise ValueError(&quot;Coordinate dimensions do not match.&quot;)

        if self.coordinates.ndim == 1:
            self.coordinates[indices] = coordinates.coordinates
        else:
            self.coordinates[:, indices] = coordinates.coordinates</div>

<div class="viewcode-block" id="Coordinate.shift"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.shift">[docs]</a>    def shift(self, n, fill_value=np.nan):
        &quot;&quot;&quot;
        Shift the coordinates by a given number of elements.

        Parameters
        ----------
        n : int
        fill_value : float or int or units.Quantity, optional

        Returns
        -------
        None
        &quot;&quot;&quot;
        if self.singular:
            return  # Can&#39;t roll for singular coordinates
        elif n == 0:
            return

        if (self.unit is not None
                and not isinstance(fill_value, units.Quantity)):
            fill_value = fill_value * self.unit

        if self.coordinates.ndim == 1:
            self.coordinates = np.roll(self.coordinates, n)
        else:
            self.coordinates = np.roll(self.coordinates, n, axis=1)

        blank = slice(0, n) if n &gt; 0 else slice(n, None)
        if self.coordinates.ndim &gt; 1:
            blank = slice(None), blank
        self.coordinates[blank] = fill_value</div>

<div class="viewcode-block" id="Coordinate.mean"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.mean">[docs]</a>    def mean(self):
        &quot;&quot;&quot;
        Return the mean coordinates.

        Returns
        -------
        mean_coordinates : Coordinate
        &quot;&quot;&quot;
        new = self.empty_copy()
        if self.coordinates is None:
            return new
        if self.singular:
            if isinstance(self.coordinates, np.ndarray):
                mean_coordinates = self.coordinates.copy()
            else:
                mean_coordinates = self.coordinates
        elif self.ndim == 1:
            mean_coordinates = np.atleast_1d(np.nanmean(self.coordinates))
        else:
            mean_coordinates = np.nanmean(self.coordinates, axis=1)

        if new.ndim == 0:
            mean_coordinates = mean_coordinates[:, None]

        new.set(mean_coordinates, copy=False)
        return new</div>

<div class="viewcode-block" id="Coordinate.copy_coordinates"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.copy_coordinates">[docs]</a>    def copy_coordinates(self, coordinates):
        &quot;&quot;&quot;
        Copy the coordinates from another system to this system.

        Parameters
        ----------
        coordinates : Coordinate

        Returns
        -------
        None
        &quot;&quot;&quot;
        self.set(coordinates.coordinates)</div>

<div class="viewcode-block" id="Coordinate.set"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.coordinate_systems.coordinate.Coordinate.html#sofia_redux.scan.coordinate_systems.coordinate.Coordinate.set">[docs]</a>    def set(self, coordinates, copy=True):
        &quot;&quot;&quot;
        Set the coordinates.

        Parameters
        ----------
        coordinates : numpy.ndarray or list
        copy : bool, optional
            If `True`, copy the coordinates.  Otherwise do a reference.

        Returns
        -------
        None
        &quot;&quot;&quot;
        coordinates, original = self.check_coordinate_units(coordinates)
        copy &amp;= original

        if self.coordinates is not None:
            if self.coordinates.ndim &gt; 1 and coordinates.ndim == 1:
                coordinates = coordinates[:, None]

        if copy and isinstance(coordinates, np.ndarray):
            self.coordinates = coordinates.copy()
        else:
            self.coordinates = coordinates</div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2023, SOFIA-USRA.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 7.1.2. &nbsp;
    Last built 13 Aug 2023. <br/>
  </p>
</footer>
  </body>
</html>