<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sofia_redux.scan.signal.signal &#8212; sofia_redux v1.3.4.dev0</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/bootstrap-sofia.css?v=3fe2c07e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    
    <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js?v=602f4d50"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script type="text/javascript" src="../../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../../_static/copybutton.js"></script>
    <link rel="icon" href="../../../../_static/redux.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../../index.html"><span id="logotext1">SOFIA</span><span id="logotext2">Redux</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="SOFIA Homepage" href="https://www.sofia.usra.edu/"></a></li>
    <li><a title="General Index" href="../../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../../index.html">sofia_redux v1.3.4.dev0</a>
	 &#187;
      </li>
      <li><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sofia_redux.scan.signal.signal</h1><div class="highlight"><pre>
<span></span># Licensed under a 3-clause BSD style license - see LICENSE.rst

from abc import ABC
from astropy.stats import gaussian_fwhm_to_sigma
from astropy import log, units
from copy import deepcopy
import numpy as np

from sofia_redux.scan.utilities import numba_functions
from sofia_redux.scan.utilities import utils
from sofia_redux.scan.signal import signal_numba_functions as snf

__all__ = [&#39;Signal&#39;]


<div class="viewcode-block" id="Signal"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal">[docs]</a>class Signal(ABC):

    referenced_attributes = [&#39;mode&#39;, &#39;integration&#39;]

    def __init__(self, integration, mode=None, values=None, is_floating=False):
        &quot;&quot;&quot;
        Initialize a Signal object.

        The Signal object is used to extract a gain signal from an integration.

        Parameters
        ----------
        integration : sofia_redux.scan.integration.integration.Integration
            The integration to which the signal belongs.
        mode : sofia_redux.scan.channels.mode.mode.Mode, optional
            The channel mode for which to create the signal.
        values : numpy.ndarray (float), optional
            Optional signal values to apply.
        is_floating : bool, optional
            If `True`, indicates that the signal values have some arbitrary DC
            offset.  This indicates that it would be advisable to &quot;level&quot;
            (subtract this offset) from the signal values before any type of
            application.
        &quot;&quot;&quot;
        self.mode = mode
        self.integration = integration
        self.value = values
        self.weight = None
        self.drifts = None
        self.sync_gains = None
        self.resolution = None
        self.drift_n = None
        self.is_floating = is_floating

        if mode is not None:
            self.sync_gains = np.zeros(mode.size, dtype=float)
            integration.add_signal(self)

        if values is not None:
            values = np.atleast_1d(values)
            self.resolution = utils.roundup_ratio(integration.size,
                                                  values.size)
            self.value = values
            self.drift_n = values.size

    def __str__(self):
        &quot;&quot;&quot;
        Return a string representation of the signal.

        Returns
        -------
        str
        &quot;&quot;&quot;
        int_id = self.integration.get_full_id(separator=&#39;|&#39;)
        mode_name = self.mode.name
        return f&quot;Signal {int_id}.{mode_name}&quot;

<div class="viewcode-block" id="Signal.copy"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.copy">[docs]</a>    def copy(self):
        &quot;&quot;&quot;
        Return a copy of the signal.

        Returns
        -------
        Signal
        &quot;&quot;&quot;
        new = self.__class__(self.integration, self.mode, values=self.value,
                             is_floating=self.is_floating)
        for key, value in self.__dict__.items():
            if key in self.referenced_attributes:
                setattr(new, key, value)
            else:
                setattr(new, key, deepcopy(value))
        return new</div>

    @property
    def size(self):
        &quot;&quot;&quot;
        Return the length of the signal.

        Returns
        -------
        n_signal : int
        &quot;&quot;&quot;
        if self.value is None:
            return 0
        return self.value.size

    @property
    def info(self):
        &quot;&quot;&quot;
        Return the info object specific to the signal integration.

        Returns
        -------
        Info
        &quot;&quot;&quot;
        return self.integration.info

    @property
    def configuration(self):
        &quot;&quot;&quot;
        Return the configuration applicable to the signal.

        Returns
        -------
        Configuration
        &quot;&quot;&quot;
        if self.info is None:
            return None
        return self.info.configuration

<div class="viewcode-block" id="Signal.get_resolution"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.get_resolution">[docs]</a>    def get_resolution(self):
        &quot;&quot;&quot;
        Return the signal resolution.

        The signal resolution is basically the number of frames for which a
        single signal value may be applicable.

        Returns
        -------
        resolution : int
        &quot;&quot;&quot;
        return self.resolution</div>

<div class="viewcode-block" id="Signal.value_at"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.value_at">[docs]</a>    def value_at(self, frame):
        &quot;&quot;&quot;
        Return the signal value for a given integration frame index.

        Parameters
        ----------
        frame : int or numpy.ndarray (int)

        Returns
        -------
        signal_value : float
        &quot;&quot;&quot;
        return self.value[frame // self.resolution]</div>

<div class="viewcode-block" id="Signal.weight_at"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.weight_at">[docs]</a>    def weight_at(self, frame):
        &quot;&quot;&quot;
        Return the signal weight for a given integration frame index.

        Note that the standard signal object does not have an
        associated weight.

        Parameters
        ----------
        frame : int or numpy.ndarray (int)

        Returns
        -------
        signal_weight : float
        &quot;&quot;&quot;
        return 1.0</div>

<div class="viewcode-block" id="Signal.scale"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.scale">[docs]</a>    def scale(self, factor):
        &quot;&quot;&quot;
        Scale the signal, drifts, and sync_gains by a given factor.

        Signal values and drifts are multiplied by the given factor.
        Sync gains (previous gain values) are divided by the given factor.

        Parameters
        ----------
        factor : float

        Returns
        -------
        None
        &quot;&quot;&quot;
        self.value *= factor
        if self.drifts is not None:
            self.drifts *= factor

        self.sync_gains /= factor</div>

<div class="viewcode-block" id="Signal.add"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.add">[docs]</a>    def add(self, value):
        &quot;&quot;&quot;
        Add a DC offset to all signal and drift values.

        Parameters
        ----------
        value : float
            The value to add.

        Returns
        -------
        None
        &quot;&quot;&quot;
        self.value += value
        if self.drifts is not None:
            self.drifts += value</div>

<div class="viewcode-block" id="Signal.subtract"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.subtract">[docs]</a>    def subtract(self, value):
        &quot;&quot;&quot;
        Subtract a DC offset from all signal and drift values.

        Parameters
        ----------
        value : float

        Returns
        -------
        None
        &quot;&quot;&quot;
        self.add(value * -1)</div>

<div class="viewcode-block" id="Signal.add_drifts"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.add_drifts">[docs]</a>    def add_drifts(self):
        &quot;&quot;&quot;
        Add the drifts onto the signal value.

        All drifts are erased following this operation.

        Returns
        -------
        None
        &quot;&quot;&quot;
        if self.drifts is None:
            return
        snf.add_drifts(
            signal_values=self.value, drifts=self.drifts,
            drift_length=self.drift_n)
        self.drifts = None</div>

<div class="viewcode-block" id="Signal.get_rms"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.get_rms">[docs]</a>    def get_rms(self):
        &quot;&quot;&quot;
        Get the signal RMS.

        Returns
        -------
        rms : float
        &quot;&quot;&quot;
        return np.sqrt(self.get_variance())</div>

<div class="viewcode-block" id="Signal.get_variance"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.get_variance">[docs]</a>    def get_variance(self):
        &quot;&quot;&quot;
        Get the signal variance.

        Returns
        -------
        variance : float
        &quot;&quot;&quot;
        return snf.get_signal_variance(self.value)</div>

<div class="viewcode-block" id="Signal.remove_drifts"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.remove_drifts">[docs]</a>    def remove_drifts(self, n_frames=None, is_reconstructable=True,
                      robust=False):
        &quot;&quot;&quot;
        Remove drifts from the signal.

        A drift is defined as the average signal for a given block of frames
        (the length of which is given by `n_frames`.  For each drift, the
        average signal value is calculated and subtracted from all signal
        values within that drift block.  If the drifts are marked as
        &quot;reconstructable&quot;, they average signal values are stored in the
        `drifts` attribute.

        Parameters
        ----------
        n_frames : int, optional
            The number of frames in each drift.  The default is the number
            of frames in the signal&#39;s integration filter time scale.
        is_reconstructable : bool, optional
            If `True`, save the drift values for later use.
        robust : bool, optional
            If `True`, the robust (median) method will be used to determined
            the average signal level for each drift.

        Returns
        -------
        None
        &quot;&quot;&quot;
        if n_frames is None:
            n_frames = self.integration.frames_for()

        n = utils.roundup_ratio(n_frames, self.resolution)

        if self.drifts is None or n != self.drift_n:
            # Add and destroy the current drifts before calculating new ones.
            self.add_drifts()
            self.drift_n = n
            drift_size = utils.roundup_ratio(self.value.size, n)
            drifts = np.zeros(drift_size, dtype=float)
            if is_reconstructable:
                self.drifts = drifts

        elif is_reconstructable:
            drifts = self.drifts

        else:
            drift_size = utils.roundup_ratio(self.value.size, n)
            drifts = np.zeros(drift_size, dtype=float)

        # Remove the mean signal and store as drifts in n_frames chunks
        snf.remove_drifts(
            signal_values=self.value,
            drifts=drifts,
            n_frames=n_frames,
            resolution=self.resolution,
            integration_size=self.integration.size,
            signal_weights=self.weight,
            robust=robust)</div>

<div class="viewcode-block" id="Signal.get_median"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.get_median">[docs]</a>    def get_median(self):
        &quot;&quot;&quot;
        Return the median signal value and weight.

        Returns
        -------
        median_value, median_weight : float, float
        &quot;&quot;&quot;
        value, _ = numba_functions.smart_median_1d(self.value)
        weight = np.inf
        return value, weight</div>

<div class="viewcode-block" id="Signal.get_mean"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.get_mean">[docs]</a>    def get_mean(self):
        &quot;&quot;&quot;
        Return the mean signal value and weight.

        Returns
        -------
        mean_value, mean_weight
        &quot;&quot;&quot;
        value, _ = numba_functions.mean(values=self.value, weights=self.weight)
        weight = np.inf
        return value, weight</div>

<div class="viewcode-block" id="Signal.differentiate"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.differentiate">[docs]</a>    def differentiate(self):
        &quot;&quot;&quot;
        Differentiate the signal values in-place.

        Note that the spacing between sample values is assumed to be in
        seconds when calculating the gradient.  The `is_floating` attribute
        is set to `False` following this operation indicating that the
        differentiated signal has no DC offset.

        Returns
        -------
        None
        &quot;&quot;&quot;
        s = self.info.instrument.sampling_interval.decompose().value
        snf.differentiate_signal(values=self.value, dt=s * self.resolution)
        self.is_floating = False</div>

<div class="viewcode-block" id="Signal.integrate"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.integrate">[docs]</a>    def integrate(self):
        &quot;&quot;&quot;
        Integrate the signal values in-place using the trapezoidal rule.

        Note that the spacing between sample values is assumed to be in
        seconds.  The `is_floating` attribute is set to `True` following this
        operation indicating that the integrated signal has an arbitrary
        DC offset.

        Returns
        -------
        None
        &quot;&quot;&quot;
        s = self.info.instrument.sampling_interval.decompose().value
        snf.integrate_signal(values=self.value, dt=s * self.resolution)
        self.is_floating = True</div>

<div class="viewcode-block" id="Signal.get_differential"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.get_differential">[docs]</a>    def get_differential(self):
        &quot;&quot;&quot;
        Return a differentiated copy of the signal.

        Returns
        -------
        Signal
        &quot;&quot;&quot;
        signal = self.copy()
        signal.differentiate()
        return signal</div>

<div class="viewcode-block" id="Signal.get_integral"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.get_integral">[docs]</a>    def get_integral(self):
        &quot;&quot;&quot;
        Return an integrated copy of the signal.

        Returns
        -------
        Signal
        &quot;&quot;&quot;
        signal = self.copy()
        signal.integrate()
        return signal</div>

<div class="viewcode-block" id="Signal.level"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.level">[docs]</a>    def level(self, start_frame=None, end_frame=None, robust=False):
        &quot;&quot;&quot;
        Remove the mean value from the signal values.

        The mean signal between a given start and end frame is calculated and
        subtracted from the signal.  This value is returned to the user.

        Parameters
        ----------
        start_frame : int, optional
            The starting frame from which to level.  The default is the first
            frame (0).
        end_frame : int, optional
            The last frame from to level (non-inclusive).  The default is the
            total number of frames.
        robust : bool, optional
            If `True`, subtract the median value rather than the mean.

        Returns
        -------
        average : float
            The average signal value that was removed.
        &quot;&quot;&quot;
        if start_frame is None:
            start_frame = 0
        if end_frame is None:
            end_frame = self.integration.size

        value = self.value
        if isinstance(value, units.Quantity):
            value = value.value

        return snf.level(
            values=value,
            start_frame=start_frame,
            end_frame=end_frame,
            resolution=self.resolution,
            robust=robust)</div>

<div class="viewcode-block" id="Signal.smooth"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.smooth">[docs]</a>    def smooth(self, fwhm):
        &quot;&quot;&quot;
        Smooth the signal to a given FWHM (given in frames).

        Parameters
        ----------
        fwhm : float or int
            The FWHM in given in units of frames.

        Returns
        -------
        None
        &quot;&quot;&quot;
        width = fwhm / self.resolution
        sigma = gaussian_fwhm_to_sigma * width
        n = 2 * (int(np.ceil(width))) + 1
        self.smooth_with_kernel(numba_functions.gaussian_kernel(n, sigma))</div>

<div class="viewcode-block" id="Signal.smooth_with_kernel"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.smooth_with_kernel">[docs]</a>    def smooth_with_kernel(self, kernel):
        &quot;&quot;&quot;
        Smooth the signal with a given kernel.

        Kernel spacing should be in units of self.resolution
        (number of frames).

        Parameters
        ----------
        kernel : numpy.ndarray (float)
            The kernel to smooth the signal values by.

        Returns
        -------
        None
        &quot;&quot;&quot;
        numba_functions.smooth_1d(self.value, kernel)</div>

<div class="viewcode-block" id="Signal.set_sync_gains"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.set_sync_gains">[docs]</a>    def set_sync_gains(self, gains):
        &quot;&quot;&quot;
        Copy the gains to the sync_gains attribute.

        Parameters
        ----------
        gains : numpy.ndarray (float)
            An array of gains to copy to sync_gains.

        Returns
        -------
        None
        &quot;&quot;&quot;
        self.sync_gains = gains.astype(float)</div>

<div class="viewcode-block" id="Signal.get_gain_increment"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.get_gain_increment">[docs]</a>    def get_gain_increment(self, robust=False):
        &quot;&quot;&quot;
        Return the gain increment and weight increment for each mode channel.

        For the robust method, the gain increment value is determined as:

        increment = median(frame_data / signal_value)

        while the maximum-likelihood method gives the gain increment as:

        increment = sum(frame_data * frame_weight * signal_value) / increment_w

        Both methods are weighted by frame_weight * signal_value^2 and result
        in an increment weight of:

        increment_w = sum(frame_weight * signal_value^2).

        Parameters
        ----------
        robust : bool, optional
            If `True`, use the robust method (median) to determine gain
            increments.  Otherwise, use the maximum-likelihood method (mean).

        Returns
        -------
        increment, increment_w : numpy.ndarray, numpy.ndarray
            The gain increment and increment weight, both of shape
            (n_channels,).
        &quot;&quot;&quot;
        if self.configuration.get_bool(&#39;signal-response&#39;):
            self.integration.comments.append(
                f&#39;{{{self.get_covariance():.2f}}}&#39;)
            log.debug(f&quot;covariance = {self.get_covariance():.2f}&quot;)

        # Precalculate the gain-weight products...
        # frames.temp_c = signal
        # frames.temp_wc = frame_weight * signal
        # frames.temp_wc2 = frame_weight * signal^2
        self.prepare_frame_temp_fields()

        if robust:
            return self.get_robust_gain_increment()
        else:
            return self.get_ml_gain_increment()</div>

<div class="viewcode-block" id="Signal.get_ml_gain_increment"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.get_ml_gain_increment">[docs]</a>    def get_ml_gain_increment(self):
        &quot;&quot;&quot;
        Get the maximum-likelihood (ML) gain increment for the signal.

        The maximum likelihood gain increment for a given channel (c) is:

        dG = sum(frame_data_{c} * frame_weight * signal_value) / dW
        dW = sum(frame_weight * signal_value^2)

        No invalid frames of modeling frames will be included in the sum.
        Additionally, no flagged samples will be included.

        Returns
        -------
        gain_increments, increment_weights : numpy.ndarray, numpy.ndarray
            The gain increments and increment weights for each channel in the
            signal mode channel group.  Both are arrays of shape (n_channels,).
        &quot;&quot;&quot;
        frames = self.integration.frames
        valid_frames = frames.valid &amp; frames.is_unflagged(&#39;MODELING_FLAGS&#39;)
        return snf.get_ml_gain_increment(
            frame_data=frames.data,
            signal_wc=frames.temp_wc,
            signal_wc2=frames.temp_wc2,
            sample_flags=frames.sample_flag,
            channel_indices=self.mode.channel_group.indices,
            valid_frames=valid_frames)</div>

<div class="viewcode-block" id="Signal.get_robust_gain_increment"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.get_robust_gain_increment">[docs]</a>    def get_robust_gain_increment(self):
        &quot;&quot;&quot;
        Get the robust (median derived) gain increment for the signal.

        The gain increment for a given channel is:

        increment = median(frame_data / signal_value)
        increment_weight = sum(frame_weight * signal_value^2)

        No invalid frames of modeling frames will be included in the sum.
        Additionally, no flagged samples will be included.

        Returns
        -------
        gain_increments, increment_weights : numpy.ndarray, numpy.ndarray
            The gain increments and increment weights for each channel in the
            signal mode channel group.  Both are arrays of shape (n_channels,).
        &quot;&quot;&quot;
        frames = self.integration.frames
        valid_frames = frames.valid &amp; frames.is_unflagged(&#39;MODELING_FLAGS&#39;)
        return snf.get_robust_gain_increment(
            frame_data=frames.data,
            signal_c=frames.temp_c,
            signal_wc2=frames.temp_wc2,
            sample_flags=frames.sample_flag,
            channel_indices=self.mode.channel_group.indices,
            valid_frames=valid_frames)</div>

<div class="viewcode-block" id="Signal.prepare_frame_temp_fields"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.prepare_frame_temp_fields">[docs]</a>    def prepare_frame_temp_fields(self):
        &quot;&quot;&quot;
        Prepare precalculated values for subsequent processing.

        The signal values are stored in the temp_* fields of the frame data.
        These contain:

        temp_c = signal_value
        temp_wc = relative_weight * signal_value
        temp_wc2 = relative_weight * signal_value^2

        Invalid frames have zero values.  Frames flagged as &quot;MODELING&quot; are
        set to zero weight.

        Returns
        -------
        None
        &quot;&quot;&quot;
        frames = self.integration.frames
        signal_values = self.value_at(np.arange(frames.size))
        snf.prepare_frame_temp_fields(
            signal_values=signal_values,
            frame_weights=frames.relative_weight,
            frame_valid=frames.valid,
            frame_modeling=frames.is_flagged(&#39;MODELING_FLAGS&#39;),
            frame_c=frames.temp_c,
            frame_wc=frames.temp_wc,
            frame_wc2=frames.temp_wc2)</div>

<div class="viewcode-block" id="Signal.get_covariance"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.get_covariance">[docs]</a>    def get_covariance(self):
        &quot;&quot;&quot;
        Return the signal covariance over all samples (frames, channels).

        The covariance only includes unflagged channels and unflagged samples.
        The signal covariance is given as:

        C = sum_{channels}(xs * xs) / sum_{channels}(ss * xx)

        where xs = sum_{frames}(w * x * s), ss = sum_{frames}(w * s * s), and
        xx = sum_{frames}(w * x * x).  Here w is the channel weight, s is the
        signal value for each frame, and x are the frame data values.

        Returns
        -------
        covariance : float
        &quot;&quot;&quot;
        channels = self.mode.channel_group.create_data_group(match_flag=0)
        frames = self.integration.frames
        covariance = snf.get_covariance(
            signal_values=self.value_at(np.arange(frames.size)),
            frame_data=frames.data,
            frame_valid=frames.valid,
            channel_indices=channels.indices,
            channel_weights=channels.weight,
            sample_flags=frames.sample_flag)

        return covariance</div>

<div class="viewcode-block" id="Signal.resync_gains"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.resync_gains">[docs]</a>    def resync_gains(self):
        &quot;&quot;&quot;
        Resynchronize gains if any changes have occurred.

        The delta gains are calculated for each channel as:
            current_gain - last_gain

        For any non-zero delta_gain, frame data (x) for that channel will be
        updated by decrementing that value by:

            x[frame, channel] -= signal[frame] * delta_gain[channel]

        Returns
        -------
        None
        &quot;&quot;&quot;
        gains = self.mode.get_gains()
        delta_gains = gains - self.sync_gains
        if np.all(delta_gains == 0):
            return  # nothing to do

        frames = self.integration.frames
        snf.resync_gains(
            frame_data=frames.data,
            signal_values=self.value,
            resolution=self.resolution,
            delta_gains=delta_gains,
            channel_indices=self.mode.channel_group.indices,
            frame_valid=frames.valid)

        self.set_sync_gains(gains)</div>

<div class="viewcode-block" id="Signal.synchronize_gains"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.synchronize_gains">[docs]</a>    def synchronize_gains(self, sum_wc2=None, is_temp_ready=True):
        &quot;&quot;&quot;
        Synchronize gains in the signal.

        If the gains have been updated, applies any changes to the data and
        updates dependencies.

        Parameters
        ----------
        sum_wc2 : numpy.ndarray (float), optional
            An array of gain weights of shape (n_channels,).
        is_temp_ready : bool, optional
            Indicates whether the frame temporary values have already been
            calculated.  These should contain::

                temp_c = signal_value
                temp_wc = relative_weight * signal_value
                temp_wc2 = relative_weight * signal_value^2

        Returns
        -------
        None
        &quot;&quot;&quot;
        if self.mode.fixed_gains:
            raise ValueError(&quot;Cannot change gains for fixed gain modes.&quot;)

        channel_group = self.mode.channel_group
        parms = self.integration.get_dependents(f&#39;gains-{self.mode.name}&#39;)

        gains = self.mode.get_gains()
        delta_gains = gains - self.sync_gains
        if (delta_gains == 0).all():
            # Do not need to resynchronize if there was no change
            return

        if not is_temp_ready:
            self.prepare_frame_temp_fields()

        if sum_wc2 is not None:

            parms.clear(channel_group)
            frames = self.integration.frames

            snf.synchronize_gains(
                frame_data=frames.data,  # Updated
                sample_flags=frames.sample_flag,
                frame_valid=frames.valid,
                modeling_frames=frames.is_flagged(&#39;MODELING_FLAGS&#39;),
                channel_indices=channel_group.indices,
                delta_gains=delta_gains,
                frame_wc2=frames.temp_wc2,
                channel_wc2=sum_wc2,
                signal_values=frames.temp_c,
                frame_parms=parms.for_frame,  # Updated
                channel_parms=parms.for_channel)  # Updated

            # Apply the updated mode dependencies
            parms.apply(channel_group)

        # Register the gains as the ones used for the signal
        self.set_sync_gains(gains)</div>

<div class="viewcode-block" id="Signal.write_signal_values"><a class="viewcode-back" href="../../../../api/sofia_redux.scan.signal.signal.Signal.html#sofia_redux.scan.signal.signal.Signal.write_signal_values">[docs]</a>    def write_signal_values(self, out_file):
        &quot;&quot;&quot;
        Write the signal information to a text file.

        Note that in crush this is the &quot;print&quot; method.

        Parameters
        ----------
        out_file : str
            The name of the file to write to.

        Returns
        -------
        None
        &quot;&quot;&quot;
        n = 1 / (self.resolution * self.integration.info.integration_time)
        n = n.decompose().value
        with open(out_file, &#39;w&#39;) as f:
            print(f&#39;# {n}&#39;, file=f)
            for value in self.value:
                print(f&#39;{value:.3e}&#39;, file=f)</div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2023, SOFIA-USRA.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 7.1.2. &nbsp;
    Last built 13 Aug 2023. <br/>
  </p>
</footer>
  </body>
</html>