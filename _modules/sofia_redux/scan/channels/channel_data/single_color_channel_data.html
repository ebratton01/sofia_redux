<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sofia_redux.scan.channels.channel_data.single_color_channel_data &#8212; sofia_redux v1.3.4.dev0</title>
    <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/bootstrap-sofia.css?v=3fe2c07e" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/plot_directive.css" />
    
    <script src="../../../../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script data-url_root="../../../../../" id="documentation_options" src="../../../../../_static/documentation_options.js?v=602f4d50"></script>
    <script src="../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script type="text/javascript" src="../../../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../../../_static/copybutton.js"></script>
    <link rel="icon" href="../../../../../_static/redux.ico"/>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../../../index.html"><span id="logotext1">SOFIA</span><span id="logotext2">Redux</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="SOFIA Homepage" href="https://www.sofia.usra.edu/"></a></li>
    <li><a title="General Index" href="../../../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../../../index.html">sofia_redux v1.3.4.dev0</a>
	 &#187;
      </li>
      <li><a href="../../../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sofia_redux.scan.channels.channel_data.single_color_channel_data</h1><div class="highlight"><pre>
<span></span># Licensed under a 3-clause BSD style license - see LICENSE.rst

from abc import abstractmethod
from astropy.stats import gaussian_fwhm_to_sigma
import numpy as np
import pandas as pd
from scipy.sparse import csr_matrix
from scipy.sparse import SparseEfficiencyWarning
from sklearn.neighbors import radius_neighbors_graph
import warnings

from sofia_redux.scan.channels.channel_data.color_arrangement_data import (
    ColorArrangementData)
from sofia_redux.scan.coordinate_systems.coordinate_2d import Coordinate2D

__all__ = [&#39;SingleColorChannelData&#39;]


<div class="viewcode-block" id="SingleColorChannelData"><a class="viewcode-back" href="../../../../../api/sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.html#sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData">[docs]</a>class SingleColorChannelData(ColorArrangementData):

    def __init__(self, channels=None):
        &quot;&quot;&quot;
        Initialize single color channel data.

        The single color channel data defines each channel as a single color
        pixel on a camera detector arranged by row and column, with a focal
        plane position.  Each pixel may defined as having no relation to other
        pixels on the same detector (independent=True), or that they do share
        some commonality (independent=False) such as overlapping sensitivities
        to the source response.

        Parameters
        ----------
        channels
        &quot;&quot;&quot;
        super().__init__(channels=channels)
        self.row = None
        self.col = None
        self.position = None
        self.independent = None

    @property
    def default_field_types(self):
        &quot;&quot;&quot;
        Return the default values for the channel attributes.

        These are used during the initial creation of the data arrays to
        populate each of the attribute arrays with a default value.  The field
        types are returned as a dictionary {attribute (str): value}.  If a
        simple initialized value is supplied, that attribute of the data
        will default to a numpy array filled with that value.  Other options
        are::

          - (value, shape): will create arrays of shape (n, shape,) filled with
            value.
          - type or class: will create empty arrays of the given type

        Special handling are provided for `units.Quantity`, `units.Unit` and
        the :class:`sofia_redux.scan.coordinate_systems.coordinate.Coordinate`
        classes.  For the coordinate type classes, a field value also may be
        provided as (class, value, shape) to create filled coordinates of shape
        (n, shape,) with the value.  Here, n is the size of the data.

        Returns
        -------
        defaults : dict
            A dictionary of the form {name (str): value}.
        &quot;&quot;&quot;
        result = super().default_field_types
        result.update({&#39;position&#39;: (Coordinate2D, &#39;arcsec&#39;),
                       &#39;independent&#39;: True,
                       &#39;row&#39;: -1,
                       &#39;col&#39;: -1})
        return result

<div class="viewcode-block" id="SingleColorChannelData.get_overlap_distances"><a class="viewcode-back" href="../../../../../api/sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.html#sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.get_overlap_distances">[docs]</a>    def get_overlap_distances(self, overlap_indices):
        &quot;&quot;&quot;
        Calculates the overlap distances.

        The overlap distances are stored in the `overlaps` attribute values.
        This should be a csr_sparse matrix of shape (n_channels, n_channels)
        where overlaps[i, j] gives the distance between channel i and
        channel j.

        Parameters
        ----------
        overlap_indices : scipy.sparse.csr.csr_matrix (bool)
            A Compressed Sparse Row (CSR) matrix of shape (channels, channels)
            where a `True` value for overlap_indices[i, j] signals that
            channel `i` overlaps with the channel `j`.

        Returns
        -------
        distances, unit : scipy.sparse.csr.csr_matrix, astropy.units.Unit
            `distances` is a Compressed Sparse Row (CSR) matrix of shape
            (channels, channels) and of float type where distances[i, j] gives
            the distance between channels i and j.  `unit` gives the distance
            unit.
        &quot;&quot;&quot;
        matrix_rows, matrix_cols = overlap_indices.nonzero()

        distances = np.hypot(
            self.position.x[matrix_rows] - self.position.x[matrix_cols],
            self.position.y[matrix_rows] - self.position.y[matrix_cols])

        good_positions = np.isfinite(distances)
        overlap_distances = csr_matrix((distances[good_positions],
                                       (matrix_rows[good_positions],
                                        matrix_cols[good_positions])),
                                       shape=overlap_indices.shape)

        return overlap_distances, self.position.unit</div>

<div class="viewcode-block" id="SingleColorChannelData.calculate_overlap_values"><a class="viewcode-back" href="../../../../../api/sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.html#sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.calculate_overlap_values">[docs]</a>    def calculate_overlap_values(self, overlap_distances, point_size):
        &quot;&quot;&quot;
        Calculates the overlap values based on overlap distances.

        The overlap values are stored in the `overlaps` attribute values.
        This should be a csr_sparse matrix of shape (n_channels, n_channels)
        where overlaps[i, j] gives the overlap value between channels i and j.

        Parameters
        ----------
        overlap_distances : scipy.sparse.csr.csr_matrix (float)
            A Compressed Sparse Row (CSR) matrix of shape (channels, channels)
            where distances[i, j] gives the distance between channels i and j.
            Although these are float values, they should be converted be in
            units of `point_size`.
        point_size : astropy.units.Quantity
            The point size for calculating the overlaps.  Typically, the beam
            FWHM.

        Returns
        -------
        None
        &quot;&quot;&quot;
        sigma = gaussian_fwhm_to_sigma * point_size.value
        matrix_rows, matrix_cols = m_ind = overlap_distances.nonzero()

        if matrix_rows.size &gt; 0:
            values = np.exp(
                -0.5 * (np.asarray(overlap_distances[m_ind])[0] / sigma) ** 2)
        else:
            values = np.zeros(0, dtype=float)

        flagged_channels = np.nonzero(
            self.is_flagged(self.flagspace.flags.BLIND
                            | self.flagspace.flags.DEAD)
            | self.independent)[0]

        valid = np.isin(matrix_rows, flagged_channels, invert=True)
        valid &amp;= np.isin(matrix_cols, flagged_channels, invert=True)
        valid &amp;= np.isfinite(values)

        overlap_values = csr_matrix((values[valid],
                                     (matrix_rows[valid], matrix_cols[valid])),
                                    shape=overlap_distances.shape)

        self.overlaps = overlap_values</div>

<div class="viewcode-block" id="SingleColorChannelData.get_pixel_count"><a class="viewcode-back" href="../../../../../api/sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.html#sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.get_pixel_count">[docs]</a>    def get_pixel_count(self):
        &quot;&quot;&quot;
        Return the number of pixels in the channels.

        Returns
        -------
        pixels : int
        &quot;&quot;&quot;
        return self.channels.size</div>

<div class="viewcode-block" id="SingleColorChannelData.get_pixels"><a class="viewcode-back" href="../../../../../api/sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.html#sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.get_pixels">[docs]</a>    def get_pixels(self):
        &quot;&quot;&quot;
        Return the pixels in the arrangement.

        Returns
        -------
        ChannelData
        &quot;&quot;&quot;
        return self.channels.data</div>

<div class="viewcode-block" id="SingleColorChannelData.get_mapping_pixels"><a class="viewcode-back" href="../../../../../api/sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.html#sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.get_mapping_pixels">[docs]</a>    def get_mapping_pixels(self, indices=None, name=None, keep_flag=None,
                           discard_flag=None, match_flag=None):
        &quot;&quot;&quot;
        Creates and returns mapping pixels.

        Parameters
        ----------
        indices : numpy.ndarray (int), optional
            The indices to reference.  If not supplied, defaults to all
            channels.
        name : str, optional
            The name of the channel group.  If not supplied, defaults to the
            name of the channel data.
        discard_flag : int or str or ChannelFlagTypes, optional
            Flags to discard_flag from the new group.
        keep_flag : int or str or ChannelFlagTypes, optional
            Keep channels with these matching flags.
        match_flag : int or str or ChannelFlagTypes, optional
            Keep only channels with a flag exactly matching this flag.

        Returns
        -------
        ChannelGroup
            A newly created channel group.
        &quot;&quot;&quot;
        return self.channels.get_observing_channels().create_group(
            name=name, keep_flag=keep_flag, discard_flag=discard_flag,
            match_flag=match_flag)</div>

<div class="viewcode-block" id="SingleColorChannelData.get_rcp_string"><a class="viewcode-back" href="../../../../../api/sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.html#sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.get_rcp_string">[docs]</a>    def get_rcp_string(self, indices=None):
        &quot;&quot;&quot;
        Return a string representation for the RCP of ALL channels.

        Parameters
        ----------
        indices : numpy.ndarray or slice, optional
            The channel indices (not fixed) to return.  The default is all
            channels.

        Returns
        -------
        str
        &quot;&quot;&quot;
        if indices is None:
            indices = slice(None)
        x_pos = self.position.x[indices].to(&#39;arcsec&#39;).value
        y_pos = self.position.y[indices].to(&#39;arcsec&#39;).value

        df = pd.DataFrame(
            {&#39;ch&#39;: list(map(lambda x: &quot;%i&quot; % x, self.fixed_index[indices])),
             &#39;[Gpnt]&#39;: list(map(lambda x: &quot;%.3f&quot; % x,
                                self.gain[indices] * self.coupling[indices])),
             &#39;[Gsky]ch&#39;: list(map(lambda x: &quot;%.3f&quot; % x, self.gain[indices])),
             &#39;dX&#39;: list(map(lambda x: &quot;%.3e&quot; % x, x_pos)),
             &#39;dY&#39;: list(map(lambda x: &quot;%.3e&quot; % x, y_pos))})
        return df.to_csv(sep=&#39;\t&#39;, index=False)</div>

<div class="viewcode-block" id="SingleColorChannelData.get_overlap_indices"><a class="viewcode-back" href="../../../../../api/sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.html#sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.get_overlap_indices">[docs]</a>    def get_overlap_indices(self, radius):
        &quot;&quot;&quot;
        Return a cross-array indicating overlapping indices.

        Parameters
        ----------
        radius : astropy.units.Quantity
            The maximum radius about which to include overlaps.

        Returns
        -------
        overlap_indices : scipy.sparse.csr.csr_matrix (bool)
            A Compressed Sparse Row (CSR) matrix of shape (channels, channels)
            where a `True` value for overlap_indices[i, j] signals that
            channel `i` overlaps with the channel `j`.
        &quot;&quot;&quot;
        return self.get_geometric_overlap_indices(radius)</div>

<div class="viewcode-block" id="SingleColorChannelData.geometric_rows"><a class="viewcode-back" href="../../../../../api/sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.html#sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.geometric_rows">[docs]</a>    @abstractmethod
    def geometric_rows(self):  # pragma: no cover
        &quot;&quot;&quot;
        Return the number of geometric rows in the detector array.

        Returns
        -------
        rows : int
        &quot;&quot;&quot;
        pass</div>

<div class="viewcode-block" id="SingleColorChannelData.geometric_cols"><a class="viewcode-back" href="../../../../../api/sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.html#sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.geometric_cols">[docs]</a>    @abstractmethod
    def geometric_cols(self):  # pragma: no cover
        &quot;&quot;&quot;
        Return the number of geometric columns in the detector array.

        Returns
        -------
        cols : int
        &quot;&quot;&quot;
        pass</div>

<div class="viewcode-block" id="SingleColorChannelData.get_geometric_overlap_indices"><a class="viewcode-back" href="../../../../../api/sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.html#sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.get_geometric_overlap_indices">[docs]</a>    def get_geometric_overlap_indices(self, radius):
        &quot;&quot;&quot;
        Return a cross-array indicating overlapping indices from data.

        Overlaps are calculated based on the geometric properties of channels
        (rows and columns).  A maximum radius must be supplied as well as the
        pixel size indicating the separation between pixels in the x and y
        directions.

        Parameters
        ----------
        radius : astropy.units.Quantity
            The maximum radius about which to include overlaps.

        Returns
        -------
        overlap_indices : scipy.sparse.csr.csr_matrix (bool)
            A Compressed Sparse Row (CSR) matrix of shape (channels, channels)
            where a `True` value for overlap_indices[i, j] signals that
            channel `i` overlaps with the channel `j`.
        &quot;&quot;&quot;
        rows = self.fixed_index // self.geometric_cols()
        cols = self.fixed_index % self.geometric_cols()
        return self.find_row_col_overlap_indices(radius, rows, cols)</div>

<div class="viewcode-block" id="SingleColorChannelData.find_row_col_overlap_indices"><a class="viewcode-back" href="../../../../../api/sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.html#sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.find_row_col_overlap_indices">[docs]</a>    def find_row_col_overlap_indices(self, radius, rows, cols):
        &quot;&quot;&quot;
        Find which pixels overlap with others within a given radius.

        Parameters
        ----------
        radius : units.Quantity
            The radius defining the maximum overlapping radius.  Should be
            provided in the same units as the SI pixel size of the parent
            channels.
        rows : numpy.ndarray (int or float)
            The row indices of the channels for which to determine overlaps.
        cols : numpy.ndarray (int or float)
            The column indices of the channels for which to determine overlaps.

        Returns
        -------
        overlaps : csr_matrix
        &quot;&quot;&quot;
        pixel_sizes = self.channels.get_si_pixel_size()
        x = cols * pixel_sizes.x.value
        y = rows * pixel_sizes.y.value
        position = np.stack((x, y), axis=1)

        max_row = self.geometric_rows() - 1
        max_col = self.geometric_cols() - 1

        keep = (cols &lt;= max_col) &amp; (rows &lt;= max_row)
        keep_inds = np.nonzero(keep)[0]
        position = position[keep]

        short_overlap_indices = self.get_positional_overlap_indices(
            position, radius.value).nonzero()

        matrix_cols = keep_inds[short_overlap_indices[0]]
        matrix_rows = keep_inds[short_overlap_indices[1]]
        overlap_matrix = csr_matrix((np.full(matrix_cols.shape, True),
                                     (matrix_rows, matrix_cols)),
                                    shape=(self.size, self.size))
        return overlap_matrix</div>

<div class="viewcode-block" id="SingleColorChannelData.get_positional_overlap_indices"><a class="viewcode-back" href="../../../../../api/sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.html#sofia_redux.scan.channels.channel_data.single_color_channel_data.SingleColorChannelData.get_positional_overlap_indices">[docs]</a>    @staticmethod
    def get_positional_overlap_indices(position, radius):
        &quot;&quot;&quot;
        Return a cross-array indicating overlapping indices from positions.

        Given a search radius, find all overlapping positions.

        Parameters
        ----------
        position : numpy.ndarray (float or int)
            An array of orthogonal 2-dimensional coordinates of shape (n, 2).
            Note that all negative positions will not be included in the
            overlaps (this is a way of flagging default values).
        radius : float
            The maximum radius about which to include overlaps.

        Returns
        -------
        overlap_indices : scipy.sparse.csr.csr_matrix (bool)
            A Compressed Sparse Row (CSR) matrix of shape (channels, channels)
            where a `True` value for overlap_indices[i, j] signals that
            channel `i` overlaps with the channel `j`.
        &quot;&quot;&quot;
        invalid = np.any(position &lt; 0, axis=1)
        if np.isnan(radius):
            radius = None
        overlap_indices = radius_neighbors_graph(position, radius,
                                                 include_self=False,
                                                 mode=&#39;connectivity&#39;)

        with warnings.catch_warnings():
            warnings.simplefilter(&#39;ignore&#39;, SparseEfficiencyWarning)
            overlap_indices[invalid, :] = 0.0
            overlap_indices[:, invalid] = 0.0
            overlap_indices.eliminate_zeros()

        return overlap_indices.astype(bool)</div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2023, SOFIA-USRA.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 7.1.2. &nbsp;
    Last built 13 Aug 2023. <br/>
  </p>
</footer>
  </body>
</html>