<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sofia_redux.instruments.exes.spatial_shift &#8212; sofia_redux v1.3.4.dev0</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/bootstrap-sofia.css?v=3fe2c07e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    
    <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js?v=602f4d50"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script type="text/javascript" src="../../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../../_static/copybutton.js"></script>
    <link rel="icon" href="../../../../_static/redux.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../../index.html"><span id="logotext1">SOFIA</span><span id="logotext2">Redux</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="SOFIA Homepage" href="https://www.sofia.usra.edu/"></a></li>
    <li><a title="General Index" href="../../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../../index.html">sofia_redux v1.3.4.dev0</a>
	 &#187;
      </li>
      <li><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sofia_redux.instruments.exes.spatial_shift</h1><div class="highlight"><pre>
<span></span># Licensed under a 3-clause BSD style license - see LICENSE.rst

from astropy import log
import numpy as np

from sofia_redux.instruments.exes import utils
from sofia_redux.instruments.exes.make_template import make_template
from sofia_redux.toolkit.utilities.fits import set_log_level

__all__ = [&#39;spatial_shift&#39;]


<div class="viewcode-block" id="spatial_shift"><a class="viewcode-back" href="../../../../api/sofia_redux.instruments.exes.spatial_shift.spatial_shift.html#sofia_redux.instruments.exes.spatial_shift.spatial_shift">[docs]</a>def spatial_shift(data, header, flat, variance,
                  illum=None, good_frames=None, sharpen=False):
    &quot;&quot;&quot;
    Shift spectra for spatial alignment.

    A shift is derived based on correlation with average spatial profile
    from all frames. The spatial template is generated using `make_template`.
    For each input frame, the image is collapsed over the spectral dimension,
    weighting by an inverse flat (squared), shifted by a small amount,
    then added to the collapsed spatial template.  This signal is calculated
    for all spatial shifts of up to 4 pixels: the spatial shift chosen
    is the one that maximizes the signal.

    Alternately, if sharpen is not set, the value maximized is the
    signal-to-noise (the above signal, divided by the collapsed uncertainty).

    The image is then shifted by the calculated value in the spatial
    direction, i.e. along the y-axis.  Input data is assumed to be undistorted
    and rotated to orient spectra along the x-axis.

    Parameters
    ----------
    data : numpy.ndarray
        Data cube, [nframe, nspec, nspat].
    header : fits.Header
        Header from FITS file.
    flat : numpy.ndarray
        Processed flat image, [nspec, nspat].
    variance : numpy.ndarray
        Variance planes corresponding to data, [nframe, nspec, nspat].
    illum : numpy.ndarray
        Indicating illuminated regions of the frame, [nspec, nspat].
        1=illuminated, 0=unilluminated, -1=pixel that does not correspond
        to any region in the raw frame.
    good_frames : array-like, optional
        Array of indices of good frames. If provided, any frame
        not in `good_frames` will be skipped.
    sharpen : bool, optional
        If set, signal will be maximized, rather than the
        signal-to-noise ratio.

    Returns
    -------
    data, variance : 2-tuple of numpy.ndarray
        Shifted data cube [nframe, nspec, nspat]
        and updated variance data [nframe, nspec, nspat].
    &quot;&quot;&quot;

    params = _verify_inputs(data, header, flat, variance, illum=illum,
                            good_frames=good_frames, sharpen=sharpen)

    log.info(&#39;Shifting data to match first image&#39;)

    with set_log_level(&#39;WARNING&#39;):
        _make_all_templates(params)
    _find_shift(params)
    shifted = _shift_data(params)

    return shifted</div>


def _verify_inputs(data, header, flat, variance, illum,
                   good_frames, sharpen):
    &quot;&quot;&quot;Check and assemble input data and options.&quot;&quot;&quot;
    # Retrieve data dimensions
    ny = header[&#39;NSPEC&#39;]
    nx = header[&#39;NSPAT&#39;]
    try:
        nz = utils.check_data_dimensions(data=data, nx=nx, ny=ny)
    except RuntimeError:
        raise RuntimeError(f&#39;Data has wrong dimensions ({data.shape}).&#39;
                           f&#39;Not shifting images.&#39;)

    # Store the order height as well
    n_slit = header.get(&#39;SLTH_PIX&#39;, ny)

    # Check that there are at least some good frames
    all_frames = np.arange(nz)
    if good_frames is None:
        good_frames = np.arange(nz)
    _, suball, _ = np.intersect1d(all_frames, good_frames,
                                  return_indices=True)
    if len(suball) == 0:
        raise RuntimeError(&#39;No good frames. Not shifting images.&#39;)

    if illum is None:
        illum = np.ones_like(data[0])

    params = {&#39;data&#39;: data, &#39;header&#39;: header, &#39;flat&#39;: flat,
              &#39;variance&#39;: variance, &#39;illum&#39;: illum,
              &#39;good_frames&#39;: good_frames, &#39;sharpen&#39;: sharpen,
              &#39;nx&#39;: nx, &#39;ny&#39;: ny, &#39;nz&#39;: nz, &#39;ns&#39;: n_slit}

    return params


def _make_all_templates(params):
    &quot;&quot;&quot;Make spatial templates for all input frames.&quot;&quot;&quot;
    header = params[&#39;header&#39;].copy()
    weight_frame = params[&#39;flat&#39;] ** 2
    illum = params[&#39;illum&#39;]
    good_frames = params[&#39;good_frames&#39;]

    data_templates = []
    std_templates = []
    for i, frame in enumerate(params[&#39;data&#39;]):
        if i not in good_frames:
            data_templates.append(None)
            std_templates.append(None)
        else:
            # Make a collapsed template from the single frame
            template = make_template(frame, header, weight_frame,
                                     illum=illum, collapsed=True)
            data_templates.append(template)

            # Also one from the variance
            template = make_template(params[&#39;variance&#39;][i], header,
                                     weight_frame,
                                     illum=illum, collapsed=True)
            std_templates.append(np.sqrt(template))

    params[&#39;data_templates&#39;] = data_templates
    params[&#39;std_templates&#39;] = std_templates

    # Also make a normalized unweighted template of the weight
    # frame itself, inverted
    template = make_template(weight_frame, header, np.ones_like(weight_frame),
                             collapsed=True)
    params[&#39;weight_template&#39;] = np.nansum(template) / template


def _correlation(comparison_template, test_template, shift_array):
    &quot;&quot;&quot;Shift and correlate template with reference.&quot;&quot;&quot;
    n_corr = shift_array.size
    corr = np.zeros(n_corr)
    for j in range(n_corr):
        signal_shift = _shift_1d_array(test_template, shift_array[j])
        corr[j] = np.nansum((comparison_template + signal_shift) ** 2)
    return shift_array[np.argmax(corr)]


def _shift_1d_array(xs, n):
    &quot;&quot;&quot;Shift a 1D array.&quot;&quot;&quot;
    e = np.empty_like(xs)
    if n == 0:
        return xs
    elif n &gt;= 0:
        e[:n] = xs[0]
        e[n:] = xs[:-n]
    else:
        e[n:] = xs[-1]
        e[:n] = xs[-n:]
    return e


def _shift_2d_array(data, n):
    &quot;&quot;&quot;Shift a 1D array.&quot;&quot;&quot;
    if n == 0:
        return data
    # Shift up/down
    e = np.roll(data, n, axis=0)
    if n &gt;= 0:
        # Shift up: fill gap at bottom
        fill = data[0, :]
        e[:n, :] = np.expand_dims(fill, axis=0)
    else:
        # Shift down: fill gap at top
        fill = data[-1, :]
        e[n:, :] = np.expand_dims(fill, axis=0)
    return e


def _find_shift(params):
    &quot;&quot;&quot;Find optimum shift.&quot;&quot;&quot;

    # Array of shifts from -4 to 4 (usually)
    n_shift = int(np.min([4, params[&#39;ns&#39;] / 3]))
    shift_array = np.arange(-n_shift, n_shift + 1, dtype=int)

    # How much to shift each frame (default 0)
    i_shift_arr = np.zeros(params[&#39;nz&#39;], dtype=int)

    comparison_template = None
    for i in range(params[&#39;nz&#39;]):
        # Signal template
        test_template = params[&#39;data_templates&#39;][i]
        if test_template is None:
            continue

        # Divide by noise template if desired
        if params[&#39;sharpen&#39;]:
            test_template /= params[&#39;std_templates&#39;][i]

        # Weight by flat, prior to shifting,
        # to prioritize source trace
        # todo: check if intent is to correct for source shift
        #  in slit or overall shift including slit -
        #  if the latter, weighting should happen after shift
        test_template *= params[&#39;weight_template&#39;]

        # Keep the first template to compare to
        if comparison_template is None:
            comparison_template = test_template
            continue

        # Find shift which maximizes contribution to S**2 or (S/N)**2,
        # checking all integer values between -n_shift and n_shift, inclusive
        best_shift = _correlation(comparison_template, test_template,
                                  shift_array)

        # Debug plots (not threadsafe!)

        # print(&#39;Frame &#39;, i, best_shift)
        # from matplotlib import pyplot as plt
        # plt.plot(comparison_template)
        # plt.plot(test_template)
        # plt.plot(_shift_1D_array(test_template, best_shift))
        # plt.show()

        # If best shift is pegged at either limit, skip it
        if best_shift == shift_array[0] or best_shift == shift_array[-1]:
            log.debug(f&#39;Spatial shift out of range for pair {i}. &#39;
                      f&#39;Setting to 0.&#39;)
        else:
            i_shift_arr[i] = best_shift

    # Remove the mean shift if it&#39;s &gt; 0 integer pixels
    mean_shift = int(np.mean(i_shift_arr))
    log.debug(f&#39;Initial shifts: {i_shift_arr}&#39;)
    log.debug(f&#39;Mean shift: {mean_shift}&#39;)
    if abs(mean_shift) &gt; 0:
        i_shift_arr -= mean_shift

    log.info(f&#39;Derived shifts for all frames: {i_shift_arr}&#39;)
    params[&#39;derived_shifts&#39;] = i_shift_arr


def _shift_data(params):
    &quot;&quot;&quot;Apply shift to data.&quot;&quot;&quot;
    shifted_data = np.full(params[&#39;data&#39;].shape, np.nan)
    shifted_variance = np.full(params[&#39;data&#39;].shape, np.nan)
    shifts = params[&#39;derived_shifts&#39;]
    for i in range(params[&#39;nz&#39;]):
        data = params[&#39;data&#39;][i]
        var = params[&#39;variance&#39;][i]
        if i not in params[&#39;good_frames&#39;] or shifts[i] == 0:
            shifted_data[i] = data
            shifted_variance[i] = var
            continue

        shifted_data[i] = _shift_2d_array(data, shifts[i])
        shifted_variance[i] = _shift_2d_array(var, shifts[i])

    return shifted_data, shifted_variance
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2023, SOFIA-USRA.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 7.1.2. &nbsp;
    Last built 13 Aug 2023. <br/>
  </p>
</footer>
  </body>
</html>