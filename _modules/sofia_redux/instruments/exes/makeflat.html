<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sofia_redux.instruments.exes.makeflat &#8212; sofia_redux v1.3.4.dev0</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/bootstrap-sofia.css?v=3fe2c07e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    
    <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js?v=602f4d50"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <script type="text/javascript" src="../../../../_static/sidebar.js"></script>
    <script type="text/javascript" src="../../../../_static/copybutton.js"></script>
    <link rel="icon" href="../../../../_static/redux.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../../index.html"><span id="logotext1">SOFIA</span><span id="logotext2">Redux</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="SOFIA Homepage" href="https://www.sofia.usra.edu/"></a></li>
    <li><a title="General Index" href="../../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../../index.html">sofia_redux v1.3.4.dev0</a>
	 &#187;
      </li>
      <li><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sofia_redux.instruments.exes.makeflat</h1><div class="highlight"><pre>
<span></span># Licensed under a 3-clause BSD style license - see LICENSE.rst

from astropy import log
import astropy.constants as const
import astropy.units as u
import numpy as np

from sofia_redux.instruments.exes.clean import clean
from sofia_redux.instruments.exes.derive_tort import derive_tort
from sofia_redux.instruments.exes.tortcoord import tortcoord
from sofia_redux.instruments.exes.utils import parse_central_wavenumber
from sofia_redux.toolkit.stats import meancomb

__all__ = [&#39;makeflat&#39;, &#39;blackbody_pnu&#39;, &#39;bnu&#39;, &#39;bb_cal_factor&#39;]


<div class="viewcode-block" id="makeflat"><a class="viewcode-back" href="../../../../api/sofia_redux.instruments.exes.makeflat.makeflat.html#sofia_redux.instruments.exes.makeflat.makeflat">[docs]</a>def makeflat(cards, header, variance, robust=4.0, radius=10,
             black_frame=None, dark=None,
             fix_tort=False, edge_method=&#39;deriv&#39;, custom_wavemap=None,
             start_pixel=None, end_pixel=None,
             top_pixel=None, bottom_pixel=None):
    &quot;&quot;&quot;
    Generate calibrated flat frame; set distortion parameters.

    The procedure is:

        1. Black, sky, and shiny frames are identified. Typically,
           only black frames are present for EXES flats.
        2. The black frame is used to set and test distortion parameters.
        3. A difference frame is calculated (typically black-dark)
           and normalized by the black-body function at the ambient
           temperature (hdr[&#39;BBTEMP&#39;]).
        4. The inverse frame (bb / (black - dark)) is calculated.
        5. Unilluminated pixels are set to zero in the inverse frame.

    Calibration is performed by multiplying science data by the output frame.

    Parameters
    ----------
    cards : numpy.ndarray
        3D cube [nframe, nspec, nspat] or 2D image [nspec, nspat] containing
        flat frames (black, sky, or shiny).
    header : fits.Header
        FITS header for the flat file.
    variance : numpy.ndarray
        Variance array, matching `cards` shape.
    robust : float, optional
        Threshold for outlier rejection in robust mean combination, specified
        as a factor times the standard deviation.
    radius : int, optional
        Pixel radius to search for good pixels, used for interpolation over
        bad pixels in the flat frames.
    black_frame : int, optional
        Index of the black frame in the input `cards` (typically 0). If
        not provided, the black frame is set as the card with the highest
        mean value.
    dark : numpy.ndarray, optional
        Slit dark frame image [nspec, nspat]. If provided, and the input
        flat has a black card only, it will be subtracted from the black
        frame to make the difference image.
    fix_tort : bool, optional
        If True, no attempt will be made to optimize distortion parameters
        for cross-dispersed modes.
    edge_method : {&#39;deriv&#39;, &#39;sqderiv&#39;, &#39;sobel&#39;}, optional
        Sets the edge enhancement method for optimizing the cross-dispersed
        distortion parameters.  May be one derivative (&#39;deriv&#39;),
        squared derivative (&#39;sqderiv&#39;), or Sobel (&#39;sobel&#39;).    custom_wavemap
    custom_wavemap : str or bool, optional
        Filename for a text file containing explicit order edges for a
        cross-dispersed mode, as whitespace-separated integers indicating
        bottom, top, left, and right edges for each order (one per line).
        If set, it is used to directly set the order mask for a
        cross-dispersed mode. If set to a value other than a string or
        None, a &#39;customWVM.dat&#39; file is expected in the current directory.
    top_pixel : int, optional
        If provided, is used to directly set the top edge of the order.
        Used for single-order modes only (medium, low); ignored for
        cross-dispersed modes.
    bottom_pixel : int, optional
        If provided, is used to directly set the bottom edge of the order.
        Used for single-order modes only (medium, low); ignored for
        cross-dispersed modes.
    start_pixel : int, optional
        If provided, is used to directly set the left edge of all orders.
        May be used for either single-order or cross-dispersed modes.
    end_pixel : int, optional
        If provided, is used to directly set the right edge of all orders.
        May be used for either single-order or cross-dispersed modes.


    Returns
    -------

    &quot;&quot;&quot;

    params = _check_inputs(cards, header, variance,
                           robust=robust, dark=dark, radius=radius)
    _set_black_frame(params, black_frame)
    _set_shiny_and_sky_frames(params)
    _set_process_type(params)
    _check_saturation(params)
    _process_cards(params)
    _calculate_responsive_quantum_efficiency(params)
    _undistort_flat(params, edge_method=edge_method,
                    fix_tort=fix_tort, custom_wavemap=custom_wavemap,
                    start_pixel=start_pixel,
                    end_pixel=end_pixel, top_pixel=top_pixel,
                    bottom_pixel=bottom_pixel)

    # If no cards/flat desired, set them to 1, now that testtort is done
    if params[&#39;cardmode&#39;] in [&#39;NONE&#39;, &#39;UNKNOWN&#39;]:
        shape = params[&#39;ny&#39;], params[&#39;nx&#39;]
        params[&#39;cards&#39;].fill(1.0)
        params[&#39;flat_variance&#39;] = np.zeros(shape, dtype=np.float64)
        params[&#39;flat&#39;] = np.ones(shape, dtype=np.float64)
        params[&#39;illum&#39;] = np.ones(shape, dtype=int)
        return params

    _create_flat(params, robust=robust)
    return params</div>


<div class="viewcode-block" id="blackbody_pnu"><a class="viewcode-back" href="../../../../api/sofia_redux.instruments.exes.makeflat.blackbody_pnu.html#sofia_redux.instruments.exes.makeflat.blackbody_pnu">[docs]</a>def blackbody_pnu(wavenumber, temperature):
    &quot;&quot;&quot;
    Black-body photon function.

    Accepts arrays for wavenumber and/or temperature, as long
    as their shapes can be broadcast together.

    Parameters
    ----------
    wavenumber : float or array-like of float
        Wavenumber values for computing the black-body function.
    temperature : float or array-like of float
        Temperature values for computing the black-body function.

    Returns
    -------
    pnu : float or array-like of float
        Photons at input values, in Hz/cm.
    &quot;&quot;&quot;
    t = u.Quantity(temperature, &#39;Kelvin&#39;)
    v = u.Quantity(wavenumber, &#39;Kayser&#39;).to(&#39;Hz&#39;, equivalencies=u.spectral())

    pnu = 2 * (v ** 2) / const.c
    pnu /= np.exp((const.h * v) / (const.k_B * t)) - 1.0
    return pnu.to(u.Hz / u.cm).value</div>


<div class="viewcode-block" id="bnu"><a class="viewcode-back" href="../../../../api/sofia_redux.instruments.exes.makeflat.bnu.html#sofia_redux.instruments.exes.makeflat.bnu">[docs]</a>def bnu(wavenumber, temperature):
    &quot;&quot;&quot;
    Black-body intensity function.

    Accepts arrays for wavenumber and/or temperature, as long
    as their shapes can be broadcast together.

    Parameters
    ----------
    wavenumber : float or array-like of float
        Wavenumber values for computing the black-body function.
    temperature : float or array-like of float
        Temperature values for computing the black-body function.

    Returns
    -------
    bnu : float or array-like of float
        Blackbody intensity in erg s-1 cm-2 (cm-1)-1.
    &quot;&quot;&quot;
    t = u.Quantity(temperature, &#39;Kelvin&#39;)
    v = u.Quantity(wavenumber, &#39;Kayser&#39;).to(&#39;Hz&#39;, equivalencies=u.spectral())

    bnu = 2 * const.h * (v ** 3) / const.c
    bnu /= np.exp((const.h * v) / (const.k_B * t)) - 1.0
    return bnu.value * 1e5</div>


<div class="viewcode-block" id="bb_cal_factor"><a class="viewcode-back" href="../../../../api/sofia_redux.instruments.exes.makeflat.bb_cal_factor.html#sofia_redux.instruments.exes.makeflat.bb_cal_factor">[docs]</a>def bb_cal_factor(wavenumber, bb_temp, flat_tamb, flat_emis):
    &quot;&quot;&quot;
    Calibration factor for EXES blackbody source + flat mirror.

    The EXES blackbody plate is located outside of the dewar,
    with one reflection off of a flat mirror before entering the
    EXES window. This flat field system seems to produce photons
    like the sum of two blackbodies:

        B(BB_TEMP, lambda) * (1-emissivity) + emissivity * B(T_ambient),

    where emissivity is (1-reflectance) of the flat mirror.

    Expected values are emissivity = 0.1. (reflectance = 0.9) and
    T_ambient = 290 K.

    Parameters
    ----------
    wavenumber : float or array-like of float
        Wavenumber values for computing the black-body function.
    bb_temp : float
        Blackbody source temperature value.
    flat_tamb : float
        Ambient temperature for flat mirror.
    flat_emis : float
        Emissivity factor (1 - reflectance) for the flat mirror.

    Returns
    -------

    &quot;&quot;&quot;
    bnu_t = bnu(wavenumber, bb_temp)
    bnu_t_amb = bnu(wavenumber, flat_tamb)

    cal_factor = bnu_t * (1 - flat_emis) + bnu_t_amb * flat_emis
    return cal_factor</div>


def _check_inputs(cards, header, variance, robust=4.0, dark=None, radius=10):
    &quot;&quot;&quot;Check input dimensions and modes.&quot;&quot;&quot;
    cards = np.asarray(cards, dtype=float)
    variance = np.asarray(variance, dtype=float)
    if cards.shape != variance.shape:
        raise ValueError(&quot;Card shape does not match variance shape&quot;)

    cardmode = str(header[&#39;CARDMODE&#39;]).strip().upper()
    instcfg = str(header[&#39;INSTCFG&#39;]).strip().upper()
    nx = int(header[&#39;NSPAT&#39;])
    ny = int(header[&#39;NSPEC&#39;])
    eperadu = float(header[&#39;EPERADU&#39;])
    slitval = float(header[&#39;SLITVAL&#39;])
    temp = float(header[&#39;BB_TEMP&#39;])
    flat_tamb = float(header[&#39;FLATTAMB&#39;])
    flat_emis = float(header[&#39;FLATEMIS&#39;])
    pixel_width = float(header[&#39;PIXELWD&#39;])
    frametime = float(header[&#39;FRAMETIM&#39;])
    gain = float(header[&#39;PAGAIN&#39;])
    satval = float(header[&#39;SATVAL&#39;])

    # Planned or updated central wavenumber
    waveno0 = parse_central_wavenumber(header)

    if dark is not None:
        dark = np.asarray(dark, dtype=float)
        if dark.shape != (ny, nx):
            raise ValueError(&quot;Dark does not match expected shape from header&quot;)

    # Check no cards or tort, or if tort is from object
    if cardmode in [&#39;NONE&#39;, &#39;UNKNOWN&#39;]:
        raise ValueError(&quot;CARDMODE is unspecified&quot;)

    # If camera, then use flatmode = shiny or sky
    if instcfg == &#39;CAMERA&#39;:
        if cardmode != &#39;SKY&#39;:
            log.info(&quot;Setting flatmode = shiny for camera mode&quot;)
            cardmode = &#39;SHINY&#39;

    # Get parameters for instrument configuration
    if instcfg in [&#39;HIGH_MED&#39;, &#39;HIGH_LOW&#39;]:
        focal_length = float(header[&#39;HRFL0&#39;])
        r_number = float(header[&#39;HRR&#39;])
    else:
        focal_length = float(header[&#39;XDFL0&#39;])
        r_number = float(header[&#39;XDR&#39;])

    frgain = frametime * gain
    if frgain &gt; 0:
        maxval = satval / frgain
    else:
        maxval = satval

    # Check cards
    if cards.ndim == 2:
        cards = cards[None]
    ncards = cards.shape[0]

    # Check the number of cards against mode
    if ncards == 1:
        cardmode = &#39;BLK&#39;
    elif ncards &lt; 3 and cardmode in [&#39;SHINY&#39;, &#39;BLKSHINY&#39;]:
        log.warning(&quot;Shiny frame not read.  Changing cardmode to BLKSKY&quot;)
        cardmode = &#39;BLKSKY&#39;

    # Check the values in each card
    means = np.empty(ncards, dtype=float)
    for i in range(ncards):
        means[i] = meancomb(cards[i].ravel(), robust=robust, returned=False)

    bad_frames = np.isnan(means)
    if bad_frames.any():
        badidx = np.nonzero(bad_frames)[0]
        for frame in badidx:
            msg = f&quot;Bad data in flat frame {frame}&quot;
            if frame &lt; 2:
                raise ValueError(f&quot;Cannot proceed: {msg}&quot;)
            elif cardmode in [&#39;SHINY&#39;, &#39;BLKSHINY&#39;]:
                log.warning(msg)
                log.info(&quot;Changing mode to BLKSKY&quot;)
                cardmode = &#39;BLKSKY&#39;
            else:
                log.info(msg)
                log.info(f&quot;This is allowable for frame: {frame}&quot;)

    return {
        &#39;cards&#39;: cards,
        &#39;variance&#39;: variance,
        &#39;header&#39;: header,
        &#39;dark&#39;: dark,
        &#39;cardmode&#39;: cardmode,
        &#39;instcfg&#39;: instcfg,
        &#39;ncards&#39;: ncards,
        &#39;nx&#39;: nx,
        &#39;ny&#39;: ny,
        &#39;eperadu&#39;: eperadu,
        &#39;slitval&#39;: slitval,
        &#39;temp&#39;: temp,
        &#39;flat_tamb&#39;: flat_tamb,
        &#39;flat_emis&#39;: flat_emis,
        &#39;waveno0&#39;: waveno0,
        &#39;focal_length&#39;: focal_length,
        &#39;r_number&#39;: r_number,
        &#39;maxval&#39;: maxval,
        &#39;pixel_width&#39;: pixel_width,
        &#39;card_means&#39;: means,
        &#39;radius&#39;: radius
    }


def _set_black_frame(params, black_frame):
    &quot;&quot;&quot;Set the black frame index.&quot;&quot;&quot;
    if black_frame is not None:
        try:
            black_frame = int(black_frame)
        except (TypeError, ValueError):
            black_frame = -1
        if not (0 &lt;= black_frame &lt; params[&#39;ncards&#39;]):
            raise ValueError(f&quot;Cannot use black_frame={black_frame} &quot;
                             f&quot;for {params[&#39;ncards&#39;]} cards&quot;)

    elif params[&#39;cardmode&#39;] == &#39;SKY&#39;:
        black_frame = 0
    else:
        black_frame = np.argmax(params[&#39;card_means&#39;])
        log.info(f&quot;Flat frame {black_frame} is brightest&quot;)

    params[&#39;black_frame&#39;] = black_frame


def _set_shiny_and_sky_frames(params):
    &quot;&quot;&quot;Set shiny and sky frame indices.&quot;&quot;&quot;
    # Note: this logic was copied from the original TEXES pipeline,
    # but shiny has never been used for EXES

    black_frame = params[&#39;black_frame&#39;]
    nc = params[&#39;ncards&#39;]
    means = params[&#39;card_means&#39;]

    if black_frame == 0:
        shiny_frame = 2
        sky_frame = 3 if (nc == 4 and (means[3] &lt; means[1])) else 1

    elif black_frame == 1:
        shiny_frame = 3
        sky_frame = 2 if (nc == 4 and (means[2] &lt; means[0])) else 0

    else:
        shiny_frame = black_frame - 2
        sky_frame = black_frame - 1

    if shiny_frame &gt;= nc:
        shiny_frame = black_frame
    if sky_frame &gt;= nc:
        sky_frame = black_frame

    if sky_frame &gt;= 2:
        sky_frame2 = sky_frame - 2
    else:
        sky_frame2 = sky_frame + 2
    if sky_frame2 &gt;= nc:
        sky_frame2 = sky_frame

    params[&#39;sky_frame&#39;] = sky_frame
    params[&#39;sky_frame2&#39;] = sky_frame2
    params[&#39;shiny_frame&#39;] = shiny_frame


def _set_process_type(params):
    &quot;&quot;&quot;Check cardmode is correct for current parameters.&quot;&quot;&quot;
    cardmode = params[&#39;cardmode&#39;]
    black_frame = params[&#39;black_frame&#39;]
    shiny_frame = params[&#39;shiny_frame&#39;]

    if cardmode in [&#39;BLK&#39;, &#39;NONE&#39;, &#39;UNKNOWN&#39;]:
        process_type = &#39;BLK&#39;

    elif cardmode in [&#39;SKY&#39;]:
        process_type = &#39;SKY&#39;

    elif cardmode in [&#39;SHINY&#39;] and shiny_frame != black_frame:
        process_type = &#39;SHINY&#39;

    elif cardmode in [&#39;BLKSKY&#39;, &#39;OBJ&#39;, &#39;BLKOBJ&#39;]:
        process_type = &#39;BLKSKY&#39;

    elif cardmode in [&#39;BLKSHINY&#39;] and shiny_frame != black_frame:
        process_type = &#39;BLKSHINY&#39;

    else:
        if shiny_frame != black_frame:
            raise ValueError(f&quot;Unrecognizable cardmode: {cardmode}&quot;)
        else:
            raise ValueError(&quot;Cardmode is unusable without shiny frame&quot;)

    params[&#39;process_type&#39;] = process_type


def _check_saturation(params, max_saturation=0.04):
    &quot;&quot;&quot;Generate a saturation mask and check for too many bad pixels.&quot;&quot;&quot;

    process_type = params[&#39;process_type&#39;]
    maxval = params[&#39;maxval&#39;]

    if maxval &lt;= 0:
        mask = np.full((params[&#39;ny&#39;], params[&#39;nx&#39;]), True)

    elif process_type == &#39;SKY&#39;:
        mask = params[&#39;cards&#39;][params[&#39;sky_frame&#39;]] &lt;= maxval

    elif process_type == &#39;SHINY&#39;:
        mask = params[&#39;cards&#39;][params[&#39;shiny_frame&#39;]] &lt;= maxval

    else:
        mask = params[&#39;cards&#39;][params[&#39;black_frame&#39;]] &lt;= maxval

    saturated = np.sum(~mask)
    if saturated &gt; (max_saturation * params[&#39;nx&#39;]):
        msg = f&quot;{saturated} pixels saturated in black.&quot;
        if process_type != &#39;SHINY&#39;:
            msg += &quot;  Try using cardmode=&#39;SHINY&#39;.&quot;
        raise ValueError(msg)

    params[&#39;mask&#39;] = mask


def _process_cards(params):
    &quot;&quot;&quot;Process flat cards according to mode.&quot;&quot;&quot;
    process_type = params[&#39;process_type&#39;]

    if process_type == &#39;BLK&#39;:
        _process_blk(params)
    elif process_type == &#39;SKY&#39;:
        _process_sky(params)
    elif process_type == &#39;SHINY&#39;:
        _process_shiny(params)
    elif process_type == &#39;BLKSKY&#39;:
        _process_blksky(params)
    elif process_type == &#39;BLKSHINY&#39;:
        _process_blkshiny(params)
    else:
        raise ValueError(&quot;Unknown process type&quot;)

    # at this point, there should be a card1 and card2 in params.
    # Replace the cards with this set
    params[&#39;cards&#39;] = np.array([params[&#39;card1&#39;], params[&#39;card2&#39;]])


def _process_blk(params):
    &quot;&quot;&quot;Make diff and stddev frames for BLK mode.&quot;&quot;&quot;
    # Accounts for change in the EXES observing pattern of only doing
    # stares at the blackbody + slit darks
    log.info(&quot;Processing BLK type cards:&quot;)
    shape = params[&#39;ny&#39;], params[&#39;nx&#39;]
    cards = params[&#39;cards&#39;]
    black_frame = params[&#39;black_frame&#39;]

    if params[&#39;dark&#39;] is None:
        log.info(&#39;No slit dark available.&#39;)
        # Mark saturated pixels
        black_card = cards[black_frame]
        card1 = black_card.copy()
        diff = card1.copy()
        card2 = np.zeros(shape, dtype=float)
        if params[&#39;sky_frame&#39;] != black_frame:
            sky_card = cards[params[&#39;sky_frame&#39;]]
            nzi = black_card != 0
            card2[nzi] = (black_card[nzi] - sky_card[nzi]) / black_card[nzi]
        params[&#39;card_variance&#39;] = params[&#39;variance&#39;][black_frame].copy()

    else:
        log.info(&#39;Subtracting slit dark.&#39;)
        black_card = cards[0]
        card1 = black_card.copy()
        card2 = black_card - params[&#39;dark&#39;].copy()
        diff = card2.copy()
        card2[black_card == 0] = 0
        params[&#39;card_variance&#39;] = params[&#39;variance&#39;][0].copy()

    params[&#39;card1&#39;] = card1
    params[&#39;card2&#39;] = card2
    params[&#39;diff&#39;] = diff
    params[&#39;stddev&#39;] = np.sqrt(params[&#39;card_variance&#39;])


def _process_sky(params):
    &quot;&quot;&quot;Make diff and stddev frames for SKY mode.&quot;&quot;&quot;
    log.info(&quot;Processing SKY type cards&quot;)
    sky_frame = params[&#39;sky_frame&#39;]
    sky_card = params[&#39;cards&#39;][sky_frame]
    card1 = sky_card.copy()
    card2 = sky_card.copy()
    diff = sky_card.copy()

    params[&#39;card1&#39;] = card1
    params[&#39;card2&#39;] = card2
    params[&#39;diff&#39;] = diff
    params[&#39;card_variance&#39;] = params[&#39;variance&#39;][sky_frame].copy()
    params[&#39;stddev&#39;] = np.sqrt(params[&#39;card_variance&#39;])


def _process_shiny(params):
    &quot;&quot;&quot;Make diff and stddev frames for SHINY mode.&quot;&quot;&quot;
    log.info(&quot;Processing SHINY type cards&quot;)
    shiny_frame = params[&#39;shiny_frame&#39;]
    shiny_card = params[&#39;cards&#39;][shiny_frame]
    sky_card = params[&#39;cards&#39;][params[&#39;sky_frame&#39;]]

    card1 = shiny_card.copy()
    diff = shiny_card.copy()
    card2 = np.zeros(shiny_card.shape, dtype=float)
    if shiny_frame != params[&#39;sky_frame&#39;]:
        nzi = shiny_card != 0
        card2[nzi] = sky_card[nzi] / shiny_card[nzi]

    params[&#39;card1&#39;] = card1
    params[&#39;card2&#39;] = card2
    params[&#39;diff&#39;] = diff
    params[&#39;card_variance&#39;] = params[&#39;variance&#39;][shiny_frame].copy()
    params[&#39;stddev&#39;] = np.sqrt(params[&#39;card_variance&#39;])


def _process_blksky(params):
    &quot;&quot;&quot;Make diff and stddev frames for BLKSKY mode.&quot;&quot;&quot;
    log.info(&quot;Processing BLKSKY type cards&quot;)
    black_frame = params[&#39;black_frame&#39;]
    shiny_frame = params[&#39;shiny_frame&#39;]

    black_card = params[&#39;cards&#39;][black_frame]
    do_dark = params[&#39;dark&#39;] is not None

    if black_frame != shiny_frame:
        card1 = black_card - params[&#39;cards&#39;][shiny_frame]
    else:
        card1 = black_card.copy()

    if do_dark:
        log.info(&#39;Subtracting slit dark instead of sky.&#39;)
        diff = black_card - params[&#39;dark&#39;]
    else:
        diff = black_card - params[&#39;cards&#39;][params[&#39;sky_frame&#39;]]

    card2 = np.zeros(black_card.shape, dtype=float)
    nzi = black_card != 0
    card2[nzi] = diff[nzi]
    if not do_dark:
        card2[nzi] /= black_card[nzi]

    params[&#39;card1&#39;] = card1
    params[&#39;card2&#39;] = card2
    params[&#39;diff&#39;] = diff
    params[&#39;card_variance&#39;] = params[&#39;variance&#39;][black_frame].copy()
    params[&#39;stddev&#39;] = np.sqrt(params[&#39;card_variance&#39;])


def _process_blkshiny(params):
    &quot;&quot;&quot;Make diff and stddev frames for BLKSHINY mode.&quot;&quot;&quot;
    log.info(&quot;Processing BLKSHINY type cards&quot;)
    black_frame = params[&#39;black_frame&#39;]
    shiny_frame = params[&#39;shiny_frame&#39;]

    black_card = params[&#39;cards&#39;][black_frame]
    shiny_card = params[&#39;cards&#39;][shiny_frame]
    sky_card = params[&#39;cards&#39;][params[&#39;sky_frame&#39;]]

    card1 = black_card - shiny_card
    diff = card1.copy()
    card2 = np.zeros(card1.shape, dtype=float)
    nzi = black_card != 0
    card2[nzi] = (black_card[nzi] - sky_card[nzi]) / black_card[nzi]

    params[&#39;card1&#39;] = card1
    params[&#39;card2&#39;] = card2
    params[&#39;diff&#39;] = diff
    params[&#39;card_variance&#39;] = params[&#39;variance&#39;][black_frame].copy()
    params[&#39;stddev&#39;] = np.sqrt(params[&#39;card_variance&#39;])


def _calculate_responsive_quantum_efficiency(params):
    &quot;&quot;&quot;Calculate RQE for the black frame.&quot;&quot;&quot;
    dwno = params[&#39;waveno0&#39;] * params[&#39;slitval&#39;]
    dwno /= 2 * params[&#39;focal_length&#39;] * params[&#39;r_number&#39;]

    pnut = blackbody_pnu(params[&#39;waveno0&#39;], params[&#39;temp&#39;])
    a_omega = (params[&#39;pixel_width&#39;] ** 2) * np.pi / (4 * 36)

    black_mean = params[&#39;card_means&#39;][params[&#39;black_frame&#39;]]
    rqe = black_mean * params[&#39;eperadu&#39;]
    rqe /= pnut * a_omega * dwno
    log.info(f&quot;Mean RQE over black frame: {rqe}&quot;)
    params[&#39;rqe&#39;] = rqe


def _undistort_flat(params, edge_method=&#39;deriv&#39;, custom_wavemap=None,
                    fix_tort=False, start_pixel=None, end_pixel=None,
                    top_pixel=None, bottom_pixel=None):
    &quot;&quot;&quot;Undistort the black frame and tune distortion parameters.&quot;&quot;&quot;
    header = params[&#39;header&#39;].copy()

    # clean card 0 before using
    card0 = params[&#39;cards&#39;][0].copy()
    card0, _ = clean(card0, params[&#39;header&#39;], params[&#39;stddev&#39;].copy(),
                     mask=params[&#39;mask&#39;], radius=params[&#39;radius&#39;])

    tortdata, tortillum = derive_tort(
        card0, header, maxiter=5, fixed=fix_tort,
        edge_method=edge_method, custom_wavemap=custom_wavemap,
        top_pixel=top_pixel, bottom_pixel=bottom_pixel,
        start_pixel=start_pixel, end_pixel=end_pixel)

    # tortdata is not used later, but tortillum is
    params[&#39;tortdata&#39;] = tortdata
    params[&#39;tortillum&#39;] = tortillum
    params[&#39;header&#39;] = header


def _create_flat(params, robust=4.0):
    &quot;&quot;&quot;Create the flat from the diff frame.&quot;&quot;&quot;

    # Clean the diff frame (normally black-sky or black-dark)
    diff = params[&#39;diff&#39;]
    header = params[&#39;header&#39;].copy()
    ny, nx = shape = params[&#39;ny&#39;], params[&#39;nx&#39;]
    illum = params[&#39;tortillum&#39;].copy()

    diff, stddev = clean(diff, header, params[&#39;stddev&#39;],
                         mask=params[&#39;mask&#39;], radius=params[&#39;radius&#39;])
    params[&#39;diff&#39;] = diff
    params[&#39;stddev&#39;] = stddev

    # Check the diff frame for overall negative value
    mean_diff = meancomb(diff.ravel(), robust=robust, returned=False)
    if mean_diff &lt;= 0:
        log.warning(&quot;Mean flat diff &lt;= 0; Setting flat = 1&quot;)
        params[&#39;flat&#39;] = np.ones(shape, dtype=np.float64)
        params[&#39;flat_variance&#39;] = np.zeros(shape, dtype=np.float64)
        params[&#39;illum&#39;] = np.ones(shape, dtype=int)
        return

    # Set flat = 0 if diff is small to prevent huge flat values.
    thrfac = float(header[&#39;THRFAC&#39;])
    if thrfac &lt; 0.2:
        dmin = 0.05 * mean_diff
    elif thrfac &gt; 1:
        dmin = 0.25 * mean_diff
    else:
        dmin = 0.25 * thrfac * mean_diff

    # Find pixels above threshold
    idx = diff &gt; dmin
    if not idx.any():
        log.warning(&quot;No pixels found above threshold; Setting flat = 1&quot;)
        params[&#39;flat&#39;] = np.ones(shape, dtype=np.float64)
        params[&#39;flat_variance&#39;] = np.zeros(shape, dtype=np.float64)
        params[&#39;illum&#39;] = np.ones(shape, dtype=int)
        return

    flat = np.zeros(shape, dtype=np.float64)
    flat_variance = np.zeros(shape, dtype=np.float64)

    cal_factor = bb_cal_factor(params[&#39;waveno0&#39;], params[&#39;temp&#39;],
                               params[&#39;flat_tamb&#39;], params[&#39;flat_emis&#39;])
    flat[idx] = cal_factor / diff[idx]
    flat_variance[idx] = ((params[&#39;stddev&#39;][idx] ** 2)
                          * (cal_factor ** 2)
                          / (diff[idx] ** 4))
    header[&#39;BNU_T&#39;] = cal_factor
    header[&#39;BUNIT&#39;] = &#39;erg s-1 cm-2 sr-1 (cm-1)-1 ct-1&#39;

    ux, uy = tortcoord(header, skew=True)
    u1 = ux.astype(int)
    v1 = uy.astype(int)
    u2 = u1 + 1
    v2 = v1 + 1

    # Check for pixels out of bounds and mark with -1
    cond1 = (u1 &gt;= 0) &amp; (u2 &lt; nx) &amp; (v1 &gt;= 0) &amp; (v2 &lt; ny)
    if not cond1.all():
        idx = np.where(~cond1)
        illum[idx] = -1

    # Check the four nearest pixels for bad values and mark with 0
    u1 = np.clip(u1, 0, nx - 1)
    u2 = np.clip(u2, 0, nx - 1)
    v1 = np.clip(v1, 0, ny - 1)
    v2 = np.clip(v2, 0, ny - 1)

    cond2 = diff[v1, u1] &lt;= dmin
    cond2 |= diff[v2, u1] &lt;= dmin
    cond2 |= diff[v1, u2] &lt;= dmin
    cond2 |= diff[v2, u2] &lt;= dmin
    idx = cond1 &amp; cond2
    if idx.any():
        illum[np.where(idx)] = 0

    # Update params
    params[&#39;header&#39;] = header
    params[&#39;illum&#39;] = illum
    params[&#39;flat&#39;] = flat
    params[&#39;flat_variance&#39;] = flat_variance
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2023, SOFIA-USRA.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 7.1.2. &nbsp;
    Last built 13 Aug 2023. <br/>
  </p>
</footer>
  </body>
</html>